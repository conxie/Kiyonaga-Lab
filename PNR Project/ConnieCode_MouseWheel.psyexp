<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="2024.2.4">
  <Settings>
    <Param val="use prefs" valType="str" updates="None" name="Audio latency priority"/>
    <Param val="use prefs" valType="str" updates="None" name="Audio lib"/>
    <Param val="" valType="str" updates="None" name="Completed URL"/>
    <Param val="auto" valType="str" updates="None" name="Data file delimiter"/>
    <Param val="u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])" valType="code" updates="None" name="Data filename"/>
    <Param val="True" valType="bool" updates="None" name="Enable Escape"/>
    <Param val="" valType="str" updates="None" name="End Message"/>
    <Param val="{'participant': '', 'session': '001'}" valType="code" updates="None" name="Experiment info"/>
    <Param val="True" valType="bool" updates="None" name="Force stereo"/>
    <Param val="True" valType="bool" updates="None" name="Full-screen window"/>
    <Param val="" valType="str" updates="None" name="HTML path"/>
    <Param val="" valType="str" updates="None" name="Incomplete URL"/>
    <Param val="testMonitor" valType="str" updates="None" name="Monitor"/>
    <Param val="[]" valType="fileList" updates="None" name="Resources"/>
    <Param val="False" valType="bool" updates="None" name="Save csv file"/>
    <Param val="False" valType="bool" updates="None" name="Save excel file"/>
    <Param val="False" valType="bool" updates="None" name="Save hdf5 file"/>
    <Param val="True" valType="bool" updates="None" name="Save log file"/>
    <Param val="True" valType="bool" updates="None" name="Save psydat file"/>
    <Param val="True" valType="bool" updates="None" name="Save wide csv file"/>
    <Param val="1" valType="num" updates="None" name="Screen"/>
    <Param val="True" valType="bool" updates="None" name="Show info dlg"/>
    <Param val="False" valType="bool" updates="None" name="Show mouse"/>
    <Param val="height" valType="str" updates="None" name="Units"/>
    <Param val="" valType="str" updates="None" name="Use version"/>
    <Param val="[1920, 1080]" valType="code" updates="None" name="Window size (pixels)"/>
    <Param val="none" valType="str" updates="None" name="backgroundFit"/>
    <Param val="" valType="str" updates="None" name="backgroundImg"/>
    <Param val="avg" valType="str" updates="None" name="blendMode"/>
    <Param val="float" valType="str" updates="None" name="clockFormat"/>
    <Param val="{'thisRow.t': 'priority.CRITICAL', 'expName': 'priority.LOW'}" valType="dict" updates="None" name="colPriority"/>
    <Param val="$[0,0,0]" valType="str" updates="None" name="color"/>
    <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
    <Param val="warning" valType="code" updates="None" name="consoleLoggingLevel"/>
    <Param val="default" valType="str" updates="None" name="ecSampleRate"/>
    <Param val="100.1.1.1" valType="str" updates="None" name="elAddress"/>
    <Param val="FILTER_LEVEL_2" valType="str" updates="None" name="elDataFiltering"/>
    <Param val="FILTER_LEVEL_OFF" valType="str" updates="None" name="elLiveFiltering"/>
    <Param val="EYELINK 1000 DESKTOP" valType="str" updates="None" name="elModel"/>
    <Param val="ELLIPSE_FIT" valType="str" updates="None" name="elPupilAlgorithm"/>
    <Param val="PUPIL_AREA" valType="str" updates="None" name="elPupilMeasure"/>
    <Param val="1000" valType="num" updates="None" name="elSampleRate"/>
    <Param val="False" valType="bool" updates="None" name="elSimMode"/>
    <Param val="RIGHT_EYE" valType="str" updates="None" name="elTrackEyes"/>
    <Param val="PUPIL_CR_TRACKING" valType="str" updates="None" name="elTrackingMode"/>
    <Param val="psychedeLights_temp" valType="str" updates="None" name="expName"/>
    <Param val="on Sync" valType="str" updates="None" name="exportHTML"/>
    <Param val="None" valType="str" updates="None" name="eyetracker"/>
    <Param val="" valType="code" updates="None" name="frameRate"/>
    <Param val="Attempting to measure frame rate of screen, please wait..." valType="str" updates="None" name="frameRateMsg"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="gpAddress"/>
    <Param val="4242" valType="num" updates="None" name="gpPort"/>
    <Param val="ioHub" valType="str" updates="None" name="keyboardBackend"/>
    <Param val="error" valType="code" updates="None" name="logging level"/>
    <Param val="True" valType="bool" updates="None" name="measureFrameRate"/>
    <Param val="('MIDDLE_BUTTON',)" valType="list" updates="None" name="mgBlink"/>
    <Param val="CONTINUOUS" valType="str" updates="None" name="mgMove"/>
    <Param val="0.5" valType="num" updates="None" name="mgSaccade"/>
    <Param val="neon.local" valType="str" updates="None" name="plCompanionAddress"/>
    <Param val="scene_camera.json" valType="file" updates="None" name="plCompanionCameraCalibration"/>
    <Param val="8080" valType="num" updates="None" name="plCompanionPort"/>
    <Param val="True" valType="bool" updates="None" name="plCompanionRecordingEnabled"/>
    <Param val="0.6" valType="num" updates="None" name="plConfidenceThreshold"/>
    <Param val="True" valType="bool" updates="None" name="plPupilCaptureRecordingEnabled"/>
    <Param val="" valType="str" updates="None" name="plPupilCaptureRecordingLocation"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="plPupilRemoteAddress"/>
    <Param val="50020" valType="num" updates="None" name="plPupilRemotePort"/>
    <Param val="1000" valType="num" updates="None" name="plPupilRemoteTimeoutMs"/>
    <Param val="False" valType="bool" updates="None" name="plPupillometryOnly"/>
    <Param val="psychopy_iohub_surface" valType="str" updates="None" name="plSurfaceName"/>
    <Param val="0" valType="code" updates="None" name="runMode"/>
    <Param val="False" valType="bool" updates="None" name="rush"/>
    <Param val="time" valType="str" updates="None" name="sortColumns"/>
    <Param val="" valType="str" updates="None" name="tbLicenseFile"/>
    <Param val="" valType="str" updates="None" name="tbModel"/>
    <Param val="60" valType="num" updates="None" name="tbSampleRate"/>
    <Param val="" valType="str" updates="None" name="tbSerialNo"/>
    <Param val="pyglet" valType="str" updates="None" name="winBackend"/>
  </Settings>
  <Routines>
    <Routine name="fixationRest">
      <RoutineSettingsComponent name="fixationRest" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="fixationRest" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drawFixation" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="imageFilePath = &quot;C:/Users/ipmmz/Desktop/psychedeLights_psychopy/&quot;;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="cueCircColor.setAutoDraw(True)&amp;#10;fixCircMask.setAutoDraw(True)&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= fixationT:&amp;#10;    key = kb.getKeys(['space', 'escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;          core.quit()" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawFixation" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_fixation" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="this_epoch = &quot;pretrial&quot;;&amp;#10;aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;fixation_rest_start&quot;, aaa().toString());&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'fixation'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData('fixationStart',str(aaa()))&amp;#10;if eyetracking == 1:&amp;#10;    # get a reference to the currently active EyeLink connection&amp;#10;    el_tracker = pylink.getEYELINK()&amp;#10;&amp;#10;    try:&amp;#10;        #start recording&amp;#10;        el_tracker.startRecording(1, 1, 1, 1) &amp;#10;        #send message to tracker to count trial number&amp;#10;        el_tracker.sendMessage('TRIALID %s' % str(trlId))&amp;#10;        el_tracker.sendMessage('fixationRest')&amp;#10;    except RuntimeError as error:&amp;#10;        print(&quot;ERROR:&quot;, error)&amp;#10;        abort_trial()&amp;#10;&amp;#10;    &amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData('fixationEnd',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_fixation" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="stim">
      <RoutineSettingsComponent name="stim" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="stim" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drawVisualStim" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="imLeft.setImage(leftImagePath[trlCntTotal].replace(os.sep, &quot;/&quot;))&amp;#10;imRight.setImage(rightImagePath[trlCntTotal].replace(os.sep, &quot;/&quot;),)&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;imLeft.setAutoDraw(True)&amp;#10;imRight.setAutoDraw(True)&amp;#10;&amp;#10;&amp;#10;&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= stimT:&amp;#10;    pass" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="imLeft.setAutoDraw(False)&amp;#10;imRight.setAutoDraw(False)&amp;#10;&amp;#10;#add left image info&amp;#10;thisExp.addData('imageLeft',imCat_left[trlCntTotal])&amp;#10;thisExp.addData('imageSubCategoryLeft',imSubcat_left[trlCntTotal])&amp;#10;thisExp.addData('imageNumLeft',imLabelNum_left[trlCntTotal])&amp;#10;&amp;#10;#add right image info&amp;#10;thisExp.addData('imageRight',imCat_right[trlCntTotal])&amp;#10;thisExp.addData('imageSubCategoryRight',imSubcat_right[trlCntTotal])&amp;#10;thisExp.addData('imageNumRight',imLabelNum_right[trlCntTotal])&amp;#10;&amp;#10;#add other info&amp;#10;thisExp.addData('stimT', stimT)" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawVisualStim" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_stim" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'stim'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_stim" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="loadExpVar">
      <RoutineSettingsComponent name="loadExpVar" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="loadExpVar" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="stimParams" plugin="None">
        <Param val="import numpy as np  # whole numpy lib is available, prepend 'np.'&amp;#10;import pandas as pd&amp;#10;import random&amp;#10;import os  # handy system and path functions&amp;#10;import sys  # to get file system encoding&amp;#10;import glob&amp;#10;&amp;#10;import string&amp;#10;import copy&amp;#10;from collections import namedtuple, OrderedDict&amp;#10;from psychopy.preferences import prefs" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="# try to import pyglet &amp; pygame &amp;#10;try:&amp;#10;    from pygame import mouse, locals, joystick, display&amp;#10;    import pygame.key&amp;#10;    import pygame.event as evt&amp;#10;    havePygame = True&amp;#10;except ImportError:&amp;#10;    havePygame = False&amp;#10;try:&amp;#10;    import pyglet&amp;#10;    havePyglet = True&amp;#10;except ImportError:&amp;#10;    havePyglet = False&amp;#10;try:&amp;#10;    import glfw&amp;#10;    if not glfw.init():&amp;#10;        raise ImportError&amp;#10;    haveGLFW = True&amp;#10;except ImportError:&amp;#10;    haveGLFW = False&amp;#10;&amp;#10;try:&amp;#10;    from collections.abc import MutableMapping&amp;#10;except ImportError:&amp;#10;    from collections import MutableMapping&amp;#10;&amp;#10;if havePygame:&amp;#10;    usePygame = True  # will become false later if win not initialised&amp;#10;else:&amp;#10;    usePygame = False&amp;#10;&amp;#10;if haveGLFW:&amp;#10;    useGLFW = True&amp;#10;else:&amp;#10;    useGLFW = False&amp;#10;&amp;#10;import psychopy.core&amp;#10;from psychopy.tools.monitorunittools import cm2pix, deg2pix, pix2cm, pix2deg&amp;#10;from psychopy import logging&amp;#10;from psychopy.constants import NOT_STARTED&amp;#10;&amp;#10;&amp;#10;# global variable to keep track of mouse buttons&amp;#10;mouseButtons = [0, 0, 0]&amp;#10;&amp;#10;&amp;#10;if havePyglet or haveGLFW:&amp;#10;    # importing from mouse takes ~250ms, so do it now&amp;#10;    if havePyglet:&amp;#10;        from pyglet.window.mouse import LEFT, MIDDLE, RIGHT&amp;#10;        from pyglet.window.key import (&amp;#10;            MOD_SHIFT,&amp;#10;            MOD_CTRL,&amp;#10;            MOD_ALT,&amp;#10;            MOD_CAPSLOCK,&amp;#10;            MOD_NUMLOCK,&amp;#10;            MOD_WINDOWS,&amp;#10;            MOD_COMMAND,&amp;#10;            MOD_OPTION,&amp;#10;            MOD_SCROLLLOCK&amp;#10;        )&amp;#10;&amp;#10;    _keyBuffer = []&amp;#10;    mouseWheelRel = numpy.array([0.0, 0.0])&amp;#10;    # list of 3 clocks that are reset on mouse button presses&amp;#10;    mouseClick = [psychopy.core.Clock(), psychopy.core.Clock(),&amp;#10;                  psychopy.core.Clock()]&amp;#10;    # container for time elapsed from last reset of mouseClick[n] for any&amp;#10;    # button pressed&amp;#10;    mouseTimes = [0.0, 0.0, 0.0]&amp;#10;    # clock for tracking time of mouse movement, reset when mouse is moved,&amp;#10;    # reset on mouse motion:&amp;#10;    mouseMove = psychopy.core.Clock()&amp;#10;    # global eventThread&amp;#10;    # eventThread = _EventDispatchThread()&amp;#10;    # eventThread.start()&amp;#10;    if haveGLFW:&amp;#10;        # GLFW keycodes for special characters&amp;#10;        _glfw_keycodes_ = {&amp;#10;            glfw.KEY_SPACE: 'space',&amp;#10;            glfw.KEY_ESCAPE: 'esc',&amp;#10;            glfw.KEY_ENTER: 'return',&amp;#10;            glfw.KEY_TAB: 'tab',&amp;#10;            glfw.KEY_BACKSPACE: 'backspace',&amp;#10;            glfw.KEY_INSERT: 'insert',&amp;#10;            glfw.KEY_DELETE: 'delete',&amp;#10;            glfw.KEY_RIGHT: 'right',&amp;#10;            glfw.KEY_LEFT: 'left',&amp;#10;            glfw.KEY_DOWN: 'down',&amp;#10;            glfw.KEY_UP: 'up',&amp;#10;            glfw.KEY_PAGE_UP: 'pageup',&amp;#10;            glfw.KEY_PAGE_DOWN: 'pagedn',&amp;#10;            glfw.KEY_HOME: 'home',&amp;#10;            glfw.KEY_END: 'end',&amp;#10;            glfw.KEY_CAPS_LOCK: 'capslock',&amp;#10;            glfw.KEY_SCROLL_LOCK: 'scrolllock',&amp;#10;            glfw.KEY_NUM_LOCK: 'numlock',&amp;#10;            glfw.KEY_PRINT_SCREEN: 'printscreen',&amp;#10;            glfw.KEY_PAUSE: 'pause',&amp;#10;            glfw.KEY_F1: 'f1',&amp;#10;            glfw.KEY_F2: 'f2',&amp;#10;            glfw.KEY_F3: 'f3',&amp;#10;            glfw.KEY_F4: 'f4',&amp;#10;            glfw.KEY_F5: 'f5',&amp;#10;            glfw.KEY_F6: 'f6',&amp;#10;            glfw.KEY_F7: 'f7',&amp;#10;            glfw.KEY_F8: 'f8',&amp;#10;            glfw.KEY_F9: 'f9',&amp;#10;            glfw.KEY_F10: 'f10',&amp;#10;            glfw.KEY_F11: 'f11',&amp;#10;            glfw.KEY_F12: 'f12',&amp;#10;            glfw.KEY_F13: 'f13',&amp;#10;            glfw.KEY_F14: 'f14',&amp;#10;            glfw.KEY_F15: 'f15',&amp;#10;            glfw.KEY_F16: 'f16',&amp;#10;            glfw.KEY_F17: 'f17',&amp;#10;            glfw.KEY_F18: 'f18',&amp;#10;            glfw.KEY_F19: 'f19',&amp;#10;            glfw.KEY_F20: 'f20',&amp;#10;            glfw.KEY_F21: 'f21',&amp;#10;            glfw.KEY_F22: 'f22',&amp;#10;            glfw.KEY_F23: 'f23',&amp;#10;            glfw.KEY_F24: 'f24',&amp;#10;            glfw.KEY_F25: 'f25',&amp;#10;        }&amp;#10;&amp;#10;useText = False  # By default _onPygletText is not used&amp;#10;&amp;#10;&amp;#10;def _onPygletText(text, emulated=False):&amp;#10;    &quot;&quot;&quot;handler for on_text pyglet events, or call directly to emulate a text&amp;#10;    event.&amp;#10;&amp;#10;    S Mathot 2012: This function only acts when the key that is pressed&amp;#10;    corresponds to a non-ASCII text character (Greek, Arabic, Hebrew, etc.).&amp;#10;    In that case the symbol that is passed to _onPygletKey() is translated&amp;#10;    into a useless 'user_key()' string. If this happens, _onPygletText takes&amp;#10;    over the role of capturing the key. Unfortunately, _onPygletText()&amp;#10;    cannot solely handle all input, because it does not respond to spacebar&amp;#10;    presses, etc.&amp;#10;    &quot;&quot;&quot;&amp;#10;&amp;#10;    global useText&amp;#10;    if not useText:  # _onPygletKey has handled the input&amp;#10;        return&amp;#10;    # This is needed because sometimes the execution&amp;#10;    # sequence is messed up (somehow)&amp;#10;    useText = False&amp;#10;    # capture when the key was pressed:&amp;#10;    keyTime = psychopy.core.getTime()&amp;#10;    if emulated:&amp;#10;        keySource = 'EmulatedKey'&amp;#10;    else:&amp;#10;        keySource = 'KeyPress'&amp;#10;    _keyBuffer.append((text.lower(), lastModifiers, keyTime))&amp;#10;    logging.data(&quot;%s: %s&quot; % (keySource, text))&amp;#10;&amp;#10;&amp;#10;def _onPygletKey(symbol, modifiers, emulated=False):&amp;#10;    &quot;&quot;&quot;handler for on_key_press pyglet events; call directly to emulate a&amp;#10;    key press&amp;#10;&amp;#10;    Appends a tuple with (keyname, timepressed) into the global _keyBuffer.&amp;#10;    The _keyBuffer can then be accessed as normal using event.getKeys(),&amp;#10;    .waitKeys(), clearBuffer(), etc.&amp;#10;&amp;#10;    J Gray 2012: Emulated means add a key (symbol) to the buffer virtually.&amp;#10;    This is useful for fMRI_launchScan, and for unit testing (in testTheApp)&amp;#10;    Logging distinguishes EmulatedKey events from real Keypress events.&amp;#10;    For emulation, the key added to the buffer is unicode(symbol), instead of&amp;#10;    pyglet.window.key.symbol_string(symbol).&amp;#10;&amp;#10;    S Mathot 2012: Implement fallback to _onPygletText&amp;#10;&amp;#10;    5AM Solutions 2016: Add the keyboard modifier flags to the key buffer.&amp;#10;&amp;#10;    M Cutone 2018: Added GLFW backend support.&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    global useText, lastModifiers&amp;#10;&amp;#10;    keyTime = psychopy.core.getTime()  # capture when the key was pressed&amp;#10;    if emulated:&amp;#10;        if not isinstance(modifiers, int):&amp;#10;            msg = 'Modifiers must be passed as an integer value.'&amp;#10;            raise ValueError(msg)&amp;#10;&amp;#10;        thisKey = str(symbol)&amp;#10;        keySource = 'EmulatedKey'&amp;#10;    else:&amp;#10;        thisKey = pyglet.window.key.symbol_string(&amp;#10;            symbol).lower()  # convert symbol into key string&amp;#10;        # convert pyglet symbols to pygame forms ( '_1'='1', 'NUM_1'='[1]')&amp;#10;        # 'user_key' indicates that Pyglet has been unable to make sense&amp;#10;        # out of the keypress. In that case, we fall back to _onPygletText&amp;#10;        # to handle the input.&amp;#10;        if 'user_key' in thisKey:&amp;#10;            useText = True&amp;#10;            lastModifiers = modifiers&amp;#10;            return&amp;#10;        useText = False&amp;#10;        thisKey = thisKey.lstrip('_').lstrip('NUM_')&amp;#10;        # Pyglet 1.3.0 returns 'enter' when Return key (0xFF0D) is pressed &amp;#10;        # in Windows Python3. So we have to replace 'enter' with 'return'.&amp;#10;        if thisKey == 'enter':&amp;#10;            thisKey = 'return'&amp;#10;        keySource = 'Keypress'&amp;#10;    _keyBuffer.append((thisKey, modifiers, keyTime))  # tuple&amp;#10;    logging.data(&quot;%s: %s&quot; % (keySource, thisKey))&amp;#10;    _process_global_event_key(thisKey, modifiers)&amp;#10;&amp;#10;&amp;#10;def _process_global_event_key(key, modifiers):&amp;#10;    if modifiers == 0:&amp;#10;        modifier_keys = ()&amp;#10;    else:&amp;#10;        modifier_keys = ['%s' % m.strip('MOD_').lower() for m in&amp;#10;                         (pyglet.window.key.modifiers_string(modifiers)&amp;#10;                          .split('|'))]&amp;#10;&amp;#10;        # Ignore Num Lock.&amp;#10;        if 'numlock' in modifier_keys:&amp;#10;            modifier_keys.remove('numlock')&amp;#10;&amp;#10;    index_key = globalKeys._gen_index_key((key, modifier_keys))&amp;#10;&amp;#10;    if index_key in globalKeys:&amp;#10;        event = globalKeys[index_key]&amp;#10;        logging.exp('Global key event: %s. Calling %s.'&amp;#10;                    % (event.name, event.func))&amp;#10;        r = event.func(*event.func_args, **event.func_kwargs)&amp;#10;        return r&amp;#10;&amp;#10;&amp;#10;def _onPygletMousePress(x, y, button, modifiers, emulated=False):&amp;#10;    &quot;&quot;&quot;button left=1, middle=2, right=4;&amp;#10;    specify multiple buttons with | operator&amp;#10;    &quot;&quot;&quot;&amp;#10;    global mouseButtons, mouseClick, mouseTimes&amp;#10;    now = psychopy.clock.getTime()&amp;#10;    if emulated:&amp;#10;        label = 'Emulated'&amp;#10;    else:&amp;#10;        label = ''&amp;#10;    if button &amp; LEFT:&amp;#10;        mouseButtons[0] = 1&amp;#10;        mouseTimes[0] = now - mouseClick[0].getLastResetTime()&amp;#10;        label += ' Left'&amp;#10;    if button &amp; MIDDLE:&amp;#10;        mouseButtons[1] = 1&amp;#10;        mouseTimes[1] = now - mouseClick[1].getLastResetTime()&amp;#10;        label += ' Middle'&amp;#10;    if button &amp; RIGHT:&amp;#10;        mouseButtons[2] = 1&amp;#10;        mouseTimes[2] = now - mouseClick[2].getLastResetTime()&amp;#10;        label += ' Right'&amp;#10;    logging.data(&quot;Mouse: %s button down, pos=(%i,%i)&quot; % (label.strip(), x, y))&amp;#10;&amp;#10;&amp;#10;def _onPygletMouseRelease(x, y, button, modifiers, emulated=False):&amp;#10;    global mouseButtons&amp;#10;    if emulated:&amp;#10;        label = 'Emulated'&amp;#10;    else:&amp;#10;        label = ''&amp;#10;    if button &amp; LEFT:&amp;#10;        mouseButtons[0] = 0&amp;#10;        label += ' Left'&amp;#10;    if button &amp; MIDDLE:&amp;#10;        mouseButtons[1] = 0&amp;#10;        label += ' Middle'&amp;#10;    if button &amp; RIGHT:&amp;#10;        mouseButtons[2] = 0&amp;#10;        label += ' Right'&amp;#10;    logging.data(&quot;Mouse: %s button up, pos=(%i,%i)&quot; % (label, x, y))&amp;#10;&amp;#10;&amp;#10;def _onPygletMouseWheel(x, y, scroll_x, scroll_y):&amp;#10;    global mouseWheelRel&amp;#10;    mouseWheelRel = mouseWheelRel + numpy.array([scroll_x, scroll_y])&amp;#10;    msg = &quot;Mouse: wheel shift=(%i,%i), pos=(%i,%i)&quot;&amp;#10;    logging.data(msg % (scroll_x, scroll_y, x, y))&amp;#10;&amp;#10;&amp;#10;# will this work? how are pyglet event handlers defined?&amp;#10;def _onPygletMouseMotion(x, y, dx, dy):&amp;#10;    global mouseMove&amp;#10;    # mouseMove is a core.Clock() that is reset when the mouse moves&amp;#10;    # default is None, but start and stopMoveClock() create and remove it,&amp;#10;    # mouseMove.reset() resets it by hand&amp;#10;    if mouseMove:&amp;#10;        mouseMove.reset()&amp;#10;&amp;#10;&amp;#10;def startMoveClock():&amp;#10;    global mouseMove&amp;#10;    mouseMove = psychopy.core.Clock()&amp;#10;&amp;#10;&amp;#10;def stopMoveClock():&amp;#10;    global mouseMove&amp;#10;    mouseMove = None&amp;#10;&amp;#10;&amp;#10;def resetMoveClock():&amp;#10;    global mouseMove&amp;#10;    if mouseMove:&amp;#10;        mouseMove.reset()&amp;#10;    else:&amp;#10;        startMoveClock()&amp;#10;&amp;#10;# class Keyboard:&amp;#10;#    &quot;&quot;&quot;The keyboard class is currently just a helper class to allow common&amp;#10;#    attributes with other objects (like mouse and stimuli). In particular&amp;#10;#    it allows storage of the .status property (NOT_STARTED, STARTED, STOPPED).&amp;#10;&amp;#10;#    It isn't really needed for most users - the functions it supports (e.g.&amp;#10;#    getKeys()) are directly callable from the event module.&amp;#10;&amp;#10;#    Note that multiple Keyboard instances will not keep separate buffers.&amp;#10;&amp;#10;#    &quot;&quot;&quot;&amp;#10;#    def __init__(self):&amp;#10;#        self.status=NOT_STARTED&amp;#10;#    def getKeys(keyList=None, timeStamped=False):&amp;#10;#        return getKeys(keyList=keyList, timeStamped=timeStamped)&amp;#10;#    def waitKeys(maxWait = None, keyList=None):&amp;#10;#        return def waitKeys(maxWait = maxWait, keyList=keyList)&amp;#10;&amp;#10;&amp;#10;def modifiers_dict(modifiers):&amp;#10;    &quot;&quot;&quot;Return dict where the key is a keyboard modifier flag&amp;#10;    and the value is the boolean state of that flag.&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    return {(mod[4:].lower()): modifiers &amp; getattr(sys.modules[__name__], mod) &gt; 0 for mod in [&amp;#10;        'MOD_SHIFT',&amp;#10;        'MOD_CTRL',&amp;#10;        'MOD_ALT',&amp;#10;        'MOD_CAPSLOCK',&amp;#10;        'MOD_NUMLOCK',&amp;#10;        'MOD_WINDOWS',&amp;#10;        'MOD_COMMAND',&amp;#10;        'MOD_OPTION',&amp;#10;        'MOD_SCROLLLOCK'&amp;#10;    ]}&amp;#10;&amp;#10;[docs]def getKeys(keyList=None, modifiers=False, timeStamped=False):&amp;#10;    &quot;&quot;&quot;Returns a list of keys that were pressed.&amp;#10;&amp;#10;    :Parameters:&amp;#10;        keyList : **None** or []&amp;#10;            Allows the user to specify a set of keys to check for.&amp;#10;            Only keypresses from this set of keys will be removed from&amp;#10;            the keyboard buffer. If the keyList is `None`, all keys will be&amp;#10;            checked and the key buffer will be cleared completely.&amp;#10;            NB, pygame doesn't return timestamps (they are always 0)&amp;#10;        modifiers : **False** or True&amp;#10;            If True will return a list of tuples instead of a list of&amp;#10;            keynames. Each tuple has (keyname, modifiers). The modifiers&amp;#10;            are a dict of keyboard modifier flags keyed by the modifier&amp;#10;            name (eg. 'shift', 'ctrl').&amp;#10;        timeStamped : **False**, True, or `Clock`&amp;#10;            If True will return a list of tuples instead of a list of&amp;#10;            keynames. Each tuple has (keyname, time). If a `core.Clock`&amp;#10;            is given then the time will be relative to the `Clock`'s last&amp;#10;            reset.&amp;#10;&amp;#10;    :Author:&amp;#10;        - 2003 written by Jon Peirce&amp;#10;        - 2009 keyList functionality added by Gary Strangman&amp;#10;        - 2009 timeStamped code provided by Dave Britton&amp;#10;        - 2016 modifiers code provided by 5AM Solutions&amp;#10;    &quot;&quot;&quot;&amp;#10;    keys = []&amp;#10;&amp;#10;    if havePygame and display.get_init():&amp;#10;        # see if pygame has anything instead (if it exists)&amp;#10;        windowSystem = 'pygame'&amp;#10;        for evts in evt.get(locals.KEYDOWN):&amp;#10;            # pygame has no keytimes&amp;#10;            keys.append((pygame.key.name(evts.key), 0))&amp;#10;&amp;#10;    global _keyBuffer&amp;#10;&amp;#10;    if havePyglet:&amp;#10;        # for each (pyglet) window, dispatch its events before checking event&amp;#10;        # buffer&amp;#10;        windowSystem = 'pyglet'&amp;#10;        for win in pyglet.app.windows:&amp;#10;            try:&amp;#10;                win.dispatch_events()  # pump events on pyglet windows&amp;#10;            except ValueError as e:  # pragma: no cover&amp;#10;                # Pressing special keys, such as 'volume-up', results in a&amp;#10;                # ValueError. This appears to be a bug in pyglet, and may be&amp;#10;                # specific to certain systems and versions of Python.&amp;#10;                logging.error(u'Failed to handle keypress')&amp;#10;&amp;#10;        if len(_keyBuffer) &gt; 0:&amp;#10;            # then pyglet is running - just use this&amp;#10;            keys = _keyBuffer&amp;#10;            # _keyBuffer = []  # DO /NOT/ CLEAR THE KEY BUFFER ENTIRELY&amp;#10;&amp;#10;    if haveGLFW:&amp;#10;        windowSystem = 'glfw'&amp;#10;        glfw.poll_events()&amp;#10;        if len(_keyBuffer) &gt; 0:&amp;#10;            keys = _keyBuffer&amp;#10;&amp;#10;    if keyList is None:&amp;#10;        _keyBuffer = []  # clear buffer entirely&amp;#10;        targets = keys  # equivalent behavior to getKeys()&amp;#10;    else:&amp;#10;        nontargets = []&amp;#10;        targets = []&amp;#10;        # split keys into keepers and pass-thrus&amp;#10;        for key in keys:&amp;#10;            if key[0] in keyList:&amp;#10;                targets.append(key)&amp;#10;            else:&amp;#10;                nontargets.append(key)&amp;#10;        _keyBuffer = nontargets  # save these&amp;#10;&amp;#10;    # now we have a list of tuples called targets&amp;#10;    # did the user want timestamped tuples or keynames?&amp;#10;    if modifiers == False and timeStamped == False:&amp;#10;        keyNames = [k[0] for k in targets]&amp;#10;        return keyNames&amp;#10;    elif timeStamped == False:&amp;#10;        keyNames = [(k[0], modifiers_dict(k[1])) for k in targets]&amp;#10;        return keyNames&amp;#10;    elif timeStamped and windowSystem=='pygame':&amp;#10;        # provide a warning and set timestamps to be None&amp;#10;        logging.warning('Pygame keyboard events do not support timestamped=True')&amp;#10;        relTuple = [[_f for _f in (k[0], modifiers and modifiers_dict(k[1]) or None, None) if _f] for k in targets]&amp;#10;        return relTuple&amp;#10;    elif hasattr(timeStamped, 'getLastResetTime'):&amp;#10;        # keys were originally time-stamped with&amp;#10;        #   core.monotonicClock._lastResetTime&amp;#10;        # we need to shift that by the difference between it and&amp;#10;        # our custom clock&amp;#10;        _last = timeStamped.getLastResetTime()&amp;#10;        _clockLast = psychopy.core.monotonicClock.getLastResetTime()&amp;#10;        timeBaseDiff = _last - _clockLast&amp;#10;        relTuple = [[_f for _f in (k[0], modifiers and modifiers_dict(k[1]) or None, k[-1] - timeBaseDiff) if _f] for k in targets]&amp;#10;        return relTuple&amp;#10;    elif timeStamped is True:&amp;#10;        return [[_f for _f in (k[0], modifiers and modifiers_dict(k[1]) or None, k[-1]) if _f] for k in targets]&amp;#10;    elif isinstance(timeStamped, (float, int, int)):&amp;#10;        relTuple = [[_f for _f in (k[0], modifiers and modifiers_dict(k[1]) or None, k[-1] - timeStamped) if _f] for k in targets]&amp;#10;        return relTuple&amp;#10;    else: ## danger - catch anything that gets here because it shouldn't!&amp;#10;        raise ValueError(&quot;We received an unknown combination of params to &quot;&amp;#10;                         &quot;getKeys(): timestamped={}, windowSystem={}, &quot;&amp;#10;                         &quot;modifiers={}&quot;&amp;#10;                        .format(timeStamped, windowSystem, modifiers))&amp;#10;&amp;#10;&amp;#10;[docs]def waitKeys(maxWait=float('inf'), keyList=None, modifiers=False,&amp;#10;             timeStamped=False, clearEvents=True):&amp;#10;    &quot;&quot;&quot;Same as `~psychopy.event.getKeys`, but halts everything&amp;#10;    (including drawing) while awaiting input from keyboard.&amp;#10;&amp;#10;    :Parameters:&amp;#10;        maxWait : any numeric value.&amp;#10;            Maximum number of seconds period and which keys to wait for.&amp;#10;            Default is float('inf') which simply waits forever.&amp;#10;        keyList : **None** or []&amp;#10;            Allows the user to specify a set of keys to check for.&amp;#10;            Only keypresses from this set of keys will be removed from&amp;#10;            the keyboard buffer. If the keyList is `None`, all keys will be&amp;#10;            checked and the key buffer will be cleared completely.&amp;#10;            NB, pygame doesn't return timestamps (they are always 0)&amp;#10;        modifiers : **False** or True&amp;#10;            If True will return a list of tuples instead of a list of&amp;#10;            keynames. Each tuple has (keyname, modifiers). The modifiers&amp;#10;            are a dict of keyboard modifier flags keyed by the modifier&amp;#10;            name (eg. 'shift', 'ctrl').&amp;#10;        timeStamped : **False**, True, or `Clock`&amp;#10;            If True will return a list of tuples instead of a list of&amp;#10;            keynames. Each tuple has (keyname, time). If a `core.Clock`&amp;#10;            is given then the time will be relative to the `Clock`'s last&amp;#10;            reset.&amp;#10;        clearEvents : **True** or False&amp;#10;            Whether to clear the keyboard event buffer (and discard preceding&amp;#10;            keypresses) before starting to monitor for new keypresses.&amp;#10;&amp;#10;    Returns None if times out.&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    if clearEvents:&amp;#10;        # Only consider keypresses from here onwards.&amp;#10;        # We need to invoke clearEvents(), but our keyword argument is&amp;#10;        # also called clearEvents. We can work around this conflict by&amp;#10;        # accessing the global scope explicitly.&amp;#10;        globals()['clearEvents']('keyboard')&amp;#10;&amp;#10;    # Check for keypresses until maxWait is exceeded&amp;#10;    #&amp;#10;    # NB pygame.event does have a wait() function that will&amp;#10;    # do this and maybe leave more cpu idle time?&amp;#10;&amp;#10;    timer = psychopy.core.Clock()&amp;#10;    got_keypress = False&amp;#10;&amp;#10;    while not got_keypress and timer.getTime() &lt; maxWait:&amp;#10;        # Get keypresses and return if anything is pressed.&amp;#10;        keys = getKeys(keyList=keyList, modifiers=modifiers,&amp;#10;                       timeStamped=timeStamped)&amp;#10;        if keys:&amp;#10;            got_keypress = True&amp;#10;&amp;#10;    if got_keypress:&amp;#10;        return keys&amp;#10;    else:&amp;#10;        logging.data('No keypress (maxWait exceeded)')&amp;#10;        return None&amp;#10;&amp;#10;&amp;#10;[docs]def xydist(p1=(0.0, 0.0), p2=(0.0, 0.0)):&amp;#10;    &quot;&quot;&quot;Helper function returning the cartesian distance between p1 and p2&amp;#10;    &quot;&quot;&quot;&amp;#10;    return numpy.sqrt(pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2))&amp;#10;&amp;#10;&amp;#10;[docs]class Mouse:&amp;#10;    &quot;&quot;&quot;Easy way to track what your mouse is doing.&amp;#10;&amp;#10;    It needn't be a class, but since Joystick works better&amp;#10;    as a class this may as well be one too for consistency&amp;#10;&amp;#10;    Create your `visual.Window` before creating a Mouse.&amp;#10;&amp;#10;    :Parameters:&amp;#10;        visible : bool or None&amp;#10;            Show the mouse if True, hide it if False, leave it as is if None (default)&amp;#10;        newPos : **None** or [x,y]&amp;#10;            gives the mouse a particular starting position&amp;#10;            (pygame `Window` only)&amp;#10;        win : **None** or `Window`&amp;#10;            the window to which this mouse is attached&amp;#10;            (the first found if None provided)&amp;#10;    &quot;&quot;&quot;&amp;#10;&amp;#10;    def __init__(self,&amp;#10;                 visible=None,&amp;#10;                 newPos=None,&amp;#10;                 win=None):&amp;#10;        super(Mouse, self).__init__()&amp;#10;        self._visible = visible&amp;#10;        self.lastPos = None&amp;#10;        self.prevPos = None  # used for motion detection and timing&amp;#10;        if win:&amp;#10;            self.win = win&amp;#10;        else:&amp;#10;            try:&amp;#10;                # to avoid circular imports, core.openWindows is defined&amp;#10;                # by visual.py and updated in core namespace;&amp;#10;                # it's circular to &quot;import visual&quot; here in event&amp;#10;                self.win = psychopy.core.openWindows[0]()&amp;#10;                logging.info('Mouse: using default window')&amp;#10;            except (NameError, IndexError):&amp;#10;                logging.error('Mouse: failed to get a default visual.Window'&amp;#10;                              ' (need to create one first)')&amp;#10;                self.win = None&amp;#10;&amp;#10;        # get the scaling factors for the display&amp;#10;        if self.win is not None:&amp;#10;            self._winScaleFactor = self.win.getContentScaleFactor()&amp;#10;        else:&amp;#10;            self._winScaleFactor = 1.0&amp;#10;&amp;#10;        # for builder: set status to STARTED, NOT_STARTED etc&amp;#10;        self.status = None&amp;#10;        self.mouseClock = psychopy.core.Clock()&amp;#10;        self.movedistance = 0.0&amp;#10;        # if pygame isn't initialised then we must use pyglet&amp;#10;        global usePygame&amp;#10;        if havePygame and not pygame.display.get_init():&amp;#10;            usePygame = False&amp;#10;        if visible is not None:&amp;#10;            self.setVisible(visible)&amp;#10;        if newPos is not None:&amp;#10;            self.setPos(newPos)&amp;#10;&amp;#10;    @property&amp;#10;    def units(self):&amp;#10;        &quot;&quot;&quot;The units for this mouse&amp;#10;        (will match the current units for the Window it lives in)&amp;#10;        &quot;&quot;&quot;&amp;#10;        return self.win.units&amp;#10;&amp;#10;[docs]    def setPos(self, newPos=(0, 0)):&amp;#10;        &quot;&quot;&quot;Sets the current position of the mouse,&amp;#10;        in the same units as the :class:`~visual.Window`. (0,0) is the center.&amp;#10;&amp;#10;        :Parameters:&amp;#10;            newPos : (x,y) or [x,y]&amp;#10;                the new position on the screen&amp;#10;        &quot;&quot;&quot;&amp;#10;        newPosPix = self._windowUnits2pix(numpy.array(newPos))&amp;#10;        if usePygame:&amp;#10;            newPosPix[1] = self.win.size[1] / 2 - newPosPix[1]&amp;#10;            newPosPix[0] = self.win.size[0] / 2 + newPosPix[0]&amp;#10;            mouse.set_pos(newPosPix)&amp;#10;        else:&amp;#10;            if hasattr(self.win.winHandle, 'set_mouse_position'):&amp;#10;                if self.win.useRetina:&amp;#10;                    newPosPix = numpy.array(self.win.size) / 4 + newPosPix / 2&amp;#10;                else:&amp;#10;                    wsf = self._winScaleFactor &amp;#10;                    newPosPix = \&amp;#10;                        numpy.array(self.win.size) / (2 * wsf) + newPosPix / wsf&amp;#10;                x, y = int(newPosPix[0]), int(newPosPix[1])&amp;#10;                self.win.winHandle.set_mouse_position(x, y)&amp;#10;                self.win.winHandle._mouse_x = x&amp;#10;                self.win.winHandle._mouse_y = y&amp;#10;            else:&amp;#10;                msg = 'mouse position could not be set (pyglet %s)'&amp;#10;                logging.error(msg % pyglet.version)&amp;#10;&amp;#10;[docs]    def getPos(self):&amp;#10;        &quot;&quot;&quot;Returns the current position of the mouse,&amp;#10;        in the same units as the :class:`~visual.Window` (0,0) is at centre&amp;#10;        &quot;&quot;&quot;&amp;#10;        lastPosPix = numpy.zeros((2,), dtype=numpy.float32)&amp;#10;        if usePygame:  # for pygame top left is 0,0&amp;#10;            lastPosPix = numpy.array(mouse.get_pos())&amp;#10;            # set (0,0) to centre&amp;#10;            lastPosPix[1] = self.win.size[1] / 2 - lastPosPix[1]&amp;#10;            lastPosPix[0] = lastPosPix[0] - self.win.size[0] / 2&amp;#10;            self.lastPos = self._pix2windowUnits(lastPosPix)&amp;#10;        elif useGLFW and self.win.winType=='glfw':&amp;#10;            lastPosPix[:] = self.win.backend.getMousePos()&amp;#10;            if self.win.useRetina:&amp;#10;                lastPosPix *= 2.0&amp;#10;        else:  # for pyglet bottom left is 0,0&amp;#10;            # use default window if we don't have one&amp;#10;            if self.win:&amp;#10;                w = self.win.winHandle&amp;#10;            else:&amp;#10;&amp;#10;                if psychopy.core.openWindows:&amp;#10;                    w = psychopy.core.openWindows[0]()&amp;#10;                else:&amp;#10;                    logging.warning(&quot;Called event.Mouse.getPos() for the mouse with no Window being opened&quot;)&amp;#10;                    return None&amp;#10;&amp;#10;            # get position in window&amp;#10;            lastPosPix[:] = w._mouse_x, w._mouse_y&amp;#10;&amp;#10;            # set (0,0) to centre&amp;#10;            if self.win.useRetina:&amp;#10;                lastPosPix = lastPosPix * 2 - numpy.array(self.win.size) / 2&amp;#10;            else:&amp;#10;                wsf = self._winScaleFactor &amp;#10;                lastPosPix = lastPosPix * wsf - numpy.array(self.win.size) / 2&amp;#10;&amp;#10;        self.lastPos = self._pix2windowUnits(lastPosPix)&amp;#10;&amp;#10;        return copy.copy(self.lastPos)&amp;#10;&amp;#10;[docs]    def mouseMoved(self, distance=None, reset=False):&amp;#10;        &quot;&quot;&quot;Determine whether/how far the mouse has moved.&amp;#10;&amp;#10;        With no args returns true if mouse has moved at all since last&amp;#10;        getPos() call, or distance (x,y) can be set to pos or neg&amp;#10;        distances from x and y to see if moved either x or y that&amp;#10;        far from lastPos, or distance can be an int/float to test if&amp;#10;        new coordinates are more than that far in a straight line&amp;#10;        from old coords.&amp;#10;&amp;#10;        Retrieve time of last movement from self.mouseClock.getTime().&amp;#10;&amp;#10;        Reset can be to 'here' or to screen coords (x,y) which allows&amp;#10;        measuring distance from there to mouse when moved. If reset is&amp;#10;        (x,y) and distance is set, then prevPos is set to (x,y) and&amp;#10;        distance from (x,y) to here is checked, mouse.lastPos is set as&amp;#10;        current (x,y) by getPos(), mouse.prevPos holds lastPos from&amp;#10;        last time mouseMoved was called.&amp;#10;        &quot;&quot;&quot;&amp;#10;        # mouseMove = clock that gets reset by pyglet mouse movement handler:&amp;#10;        global mouseMove&amp;#10;        # needs initialization before getPos resets lastPos&amp;#10;        self.prevPos = copy.copy(self.lastPos)&amp;#10;        self.getPos()  # sets self.lastPos to current position&amp;#10;        if not reset:&amp;#10;            if distance is None:&amp;#10;                if self.prevPos[0] != self.lastPos[0]:&amp;#10;                    return True&amp;#10;                if self.prevPos[1] != self.lastPos[1]:&amp;#10;                    return True&amp;#10;            else:&amp;#10;                if isinstance(distance, int) or isinstance(distance, float):&amp;#10;                    self.movedistance = xydist(self.prevPos, self.lastPos)&amp;#10;                    if self.movedistance &gt; distance:&amp;#10;                        return True&amp;#10;                    else:&amp;#10;                        return False&amp;#10;                if self.prevPos[0] + distance[0] - self.lastPos[0] &gt; 0.0:&amp;#10;                    return True  # moved on X-axis&amp;#10;                if self.prevPos[1] + distance[1] - self.lastPos[0] &gt; 0.0:&amp;#10;                    return True  # moved on Y-axis&amp;#10;            return False&amp;#10;        if reset is True:&amp;#10;            # just reset the last move time: starts/zeroes the move clock&amp;#10;            mouseMove.reset()  # resets the global mouseMove clock&amp;#10;            return False&amp;#10;        if reset == 'here':&amp;#10;            # set to wherever we are&amp;#10;            self.prevPos = copy.copy(self.lastPos)  # lastPos set in getPos()&amp;#10;            return False&amp;#10;        if hasattr(reset, '__len__'):&amp;#10;            # a tuple or list of (x,y)&amp;#10;            # reset to (x,y) to check movement from there&amp;#10;            self.prevPos = copy.copy(reset)&amp;#10;            if not distance:&amp;#10;                return False  # just resetting prevPos, not checking distance&amp;#10;            else:&amp;#10;                # checking distance of current pos to newly reset prevposition&amp;#10;                if isinstance(distance, int) or isinstance(distance, float):&amp;#10;                    self.movedistance = xydist(self.prevPos, self.lastPos)&amp;#10;                    if self.movedistance &gt; distance:&amp;#10;                        return True&amp;#10;                    else:&amp;#10;                        return False&amp;#10;                # distance is x,y tuple, to check if the mouse moved that&amp;#10;                # far on either x or y axis&amp;#10;                # distance must be (dx,dy), and reset is (rx,ry), current pos&amp;#10;                # (cx,cy): Is cx-rx &gt; dx ?&amp;#10;                if abs(self.lastPos[0] - self.prevPos[0]) &gt; distance[0]:&amp;#10;                    return True  # moved on X-axis&amp;#10;                if abs(self.lastPos[1] - self.prevPos[1]) &gt; distance[1]:&amp;#10;                    return True  # moved on Y-axis&amp;#10;            return False&amp;#10;        return False&amp;#10;&amp;#10;[docs]    def mouseMoveTime(self):&amp;#10;        global mouseMove&amp;#10;        if mouseMove:&amp;#10;            return mouseMove.getTime()&amp;#10;        else:&amp;#10;            return 0  # mouseMove clock not started&amp;#10;&amp;#10;[docs]    def getRel(self):&amp;#10;        &quot;&quot;&quot;Returns the new position of the mouse relative to the&amp;#10;        last call to getRel or getPos, in the same units as the&amp;#10;        :class:`~visual.Window`.&amp;#10;        &quot;&quot;&quot;&amp;#10;        if usePygame:&amp;#10;            relPosPix = numpy.array(mouse.get_rel()) * [1, -1]&amp;#10;            return self._pix2windowUnits(relPosPix)&amp;#10;        else:&amp;#10;            # NB getPost() resets lastPos so MUST retrieve lastPos first&amp;#10;            if self.lastPos is None:&amp;#10;                relPos = self.getPos()&amp;#10;            else:&amp;#10;                # DON't switch to (this-lastPos)&amp;#10;                relPos = -self.lastPos + self.getPos()&amp;#10;            return relPos&amp;#10;&amp;#10;[docs]    def getWheelRel(self):&amp;#10;        &quot;&quot;&quot;Returns the travel of the mouse scroll wheel since last call.&amp;#10;        Returns a numpy.array(x,y) but for most wheels y is the only&amp;#10;        value that will change (except Mac mighty mice?)&amp;#10;        &quot;&quot;&quot;&amp;#10;        global mouseWheelRel&amp;#10;        rel = mouseWheelRel&amp;#10;        mouseWheelRel = numpy.array([0.0, 0.0])&amp;#10;        return rel&amp;#10;&amp;#10;    @property&amp;#10;    def visible(self):&amp;#10;        &quot;&quot;&quot;Gets the visibility of the mouse (1 or 0)&amp;#10;        &quot;&quot;&quot;&amp;#10;        if usePygame:&amp;#10;            return mouse.get_visible()&amp;#10;        else:&amp;#10;            print(&quot;Getting the mouse visibility is not supported under&quot;&amp;#10;                  &quot; pyglet, but you can set it anyway&quot;)&amp;#10;    &amp;#10;    @visible.setter&amp;#10;    def visible(self, visible):&amp;#10;        &quot;&quot;&quot;Sets the visibility of the mouse to 1 or 0&amp;#10;&amp;#10;        NB when the mouse is not visible its absolute position is held&amp;#10;        at (0, 0) to prevent it from going off the screen and getting lost!&amp;#10;        You can still use getRel() in that case.&amp;#10;        &quot;&quot;&quot;&amp;#10;        self.setVisible(visible)&amp;#10;&amp;#10;[docs]    def getVisible(self):&amp;#10;        &quot;&quot;&quot;Gets the visibility of the mouse (1 or 0)&amp;#10;        &quot;&quot;&quot;&amp;#10;        if usePygame:&amp;#10;            return mouse.get_visible()&amp;#10;        &amp;#10;        return self._visible&amp;#10;&amp;#10;[docs]    def setVisible(self, visible):&amp;#10;        &quot;&quot;&quot;Sets the visibility of the mouse to 1 or 0&amp;#10;&amp;#10;        NB when the mouse is not visible its absolute position is held&amp;#10;        at (0, 0) to prevent it from going off the screen and getting lost!&amp;#10;        You can still use getRel() in that case.&amp;#10;        &quot;&quot;&quot;&amp;#10;        if self.win:  # use default window if we don't have one&amp;#10;            self.win.setMouseVisible(visible)&amp;#10;        elif usePygame:&amp;#10;            mouse.set_visible(visible)&amp;#10;        else:&amp;#10;            from psychopy.visual import openWindows&amp;#10;            if openWindows:&amp;#10;                w = openWindows[0]()  # type: psychopy.visual.Window&amp;#10;            else:&amp;#10;                logging.warning(&amp;#10;                    &quot;Called event.Mouse.getPos() for the mouse with no Window &quot; &amp;#10;                    &quot;being opened&quot;)&amp;#10;                return None&amp;#10;            w.setMouseVisible(visible)&amp;#10;            &amp;#10;        self._visible = visible  # set internal state&amp;#10;&amp;#10;[docs]    def clickReset(self, buttons=(0, 1, 2)):&amp;#10;        &quot;&quot;&quot;Reset a 3-item list of core.Clocks use in timing button clicks.&amp;#10;&amp;#10;        The pyglet mouse-button-pressed handler uses their&amp;#10;        clock.getLastResetTime() when a button is pressed so the user&amp;#10;        can reset them at stimulus onset or offset to measure RT. The&amp;#10;        default is to reset all, but they can be reset individually as&amp;#10;        specified in buttons list&amp;#10;        &quot;&quot;&quot;&amp;#10;        global mouseClick&amp;#10;        for c in buttons:&amp;#10;            mouseClick[c].reset()&amp;#10;            mouseTimes[c] = 0.0&amp;#10;&amp;#10;[docs]    def getPressed(self, getTime=False):&amp;#10;        &quot;&quot;&quot;Returns a 3-item list indicating whether or not buttons 0,1,2&amp;#10;        are currently pressed.&amp;#10;&amp;#10;        If `getTime=True` (False by default) then `getPressed` will&amp;#10;        return all buttons that have been pressed since the last call&amp;#10;        to `mouse.clickReset` as well as their time stamps::&amp;#10;&amp;#10;            buttons = mouse.getPressed()&amp;#10;            buttons, times = mouse.getPressed(getTime=True)&amp;#10;&amp;#10;        Typically you want to call :ref:`mouse.clickReset()` at stimulus&amp;#10;        onset, then after the button is pressed in reaction to it, the&amp;#10;        total time elapsed from the last reset to click is in mouseTimes.&amp;#10;        This is the actual RT, regardless of when the call to `getPressed()`&amp;#10;        was made.&amp;#10;&amp;#10;        &quot;&quot;&quot;&amp;#10;        global mouseButtons, mouseTimes&amp;#10;        if usePygame:&amp;#10;            return mouse.get_pressed()&amp;#10;        else:&amp;#10;            # for each (pyglet) window, dispatch its events before checking&amp;#10;            # event buffer&amp;#10;            if havePyglet:&amp;#10;                for win in pyglet.app.windows:&amp;#10;                    win.dispatch_events()  # pump events on pyglet windows&amp;#10;&amp;#10;            if haveGLFW:&amp;#10;                glfw.poll_events()&amp;#10;&amp;#10;            # else:&amp;#10;            if not getTime:&amp;#10;                return copy.copy(mouseButtons)&amp;#10;            else:&amp;#10;                return copy.copy(mouseButtons), copy.copy(mouseTimes)&amp;#10;&amp;#10;[docs]    def isPressedIn(self, shape, buttons=(0, 1, 2)):&amp;#10;        &quot;&quot;&quot;Returns `True` if the mouse is currently inside the shape and&amp;#10;        one of the mouse buttons is pressed. The default is that any of&amp;#10;        the 3 buttons can indicate a click; for only a left-click,&amp;#10;        specify `buttons=[0]`::&amp;#10;&amp;#10;            if mouse.isPressedIn(shape):&amp;#10;            if mouse.isPressedIn(shape, buttons=[0]):  # left-clicks only&amp;#10;&amp;#10;        Ideally, `shape` can be anything that has a `.contains()` method,&amp;#10;        like `ShapeStim` or `Polygon`. Not tested with `ImageStim`.&amp;#10;        &quot;&quot;&quot;&amp;#10;        wanted = numpy.zeros(3, dtype=int)&amp;#10;        for c in buttons:&amp;#10;            wanted[c] = 1&amp;#10;        pressed = self.getPressed()&amp;#10;        return any(wanted &amp; pressed) and shape.contains(self)&amp;#10;&amp;#10;    def _pix2windowUnits(self, pos):&amp;#10;        if self.win.units == 'pix':&amp;#10;            if self.win.useRetina:&amp;#10;                pos /= 2.0&amp;#10;            return pos&amp;#10;        elif self.win.units == 'norm':&amp;#10;            return pos * 2.0 / self.win.size&amp;#10;        elif self.win.units == 'cm':&amp;#10;            return pix2cm(pos, self.win.monitor)&amp;#10;        elif self.win.units == 'deg':&amp;#10;            return pix2deg(pos, self.win.monitor)&amp;#10;        elif self.win.units == 'height':&amp;#10;            return pos / float(self.win.size[1])&amp;#10;&amp;#10;    def _windowUnits2pix(self, pos):&amp;#10;        if self.win.units == 'pix':&amp;#10;            return pos&amp;#10;        elif self.win.units == 'norm':&amp;#10;            return pos * self.win.size / 2.0&amp;#10;        elif self.win.units == 'cm':&amp;#10;            return cm2pix(pos, self.win.monitor)&amp;#10;        elif self.win.units == 'deg':&amp;#10;            return deg2pix(pos, self.win.monitor)&amp;#10;        elif self.win.units == 'height':&amp;#10;            return pos * float(self.win.size[1])&amp;#10;&amp;#10;[docs]    def setExclusive(self, exclusivity):&amp;#10;        &quot;&quot;&quot;Binds the mouse to the experiment window. Only works in Pyglet.&amp;#10;&amp;#10;        In multi-monitor settings, or with a window that is not fullscreen,&amp;#10;        the mouse pointer can drift, and thereby PsychoPy might not get the&amp;#10;        events from that window. setExclusive(True) works with Pyglet to&amp;#10;        bind the mouse to the experiment window.&amp;#10;&amp;#10;        Note that binding the mouse pointer to a window will cause the&amp;#10;        pointer to vanish, and absolute positions will no longer be&amp;#10;        meaningful getPos() returns [0, 0] in this case.&amp;#10;        &quot;&quot;&quot;&amp;#10;        if type(exclusivity) is not bool:&amp;#10;            raise ValueError('Exclusivity must be a boolean!')&amp;#10;        if not usePygame:&amp;#10;            msg = ('Setting mouse exclusivity in Pyglet will cause the '&amp;#10;                   'cursor to disappear, and getPos() will be rendered '&amp;#10;                   'meaningless, returning [0, 0]')&amp;#10;            psychopy.logging.warning(msg)&amp;#10;            self.win.winHandle.set_exclusive_mouse(exclusivity)&amp;#10;        else:&amp;#10;            print('Mouse exclusivity can only be set for Pyglet!')&amp;#10;&amp;#10;&amp;#10;class BuilderKeyResponse():&amp;#10;    &quot;&quot;&quot;Used in scripts created by the builder to keep track of a clock and&amp;#10;    the current status (whether or not we are currently checking the keyboard)&amp;#10;    &quot;&quot;&quot;&amp;#10;&amp;#10;    def __init__(self):&amp;#10;        super(BuilderKeyResponse, self).__init__()&amp;#10;        self.status = NOT_STARTED&amp;#10;        self.keys = []  # the key(s) pressed&amp;#10;        self.corr = 0  # was the resp correct this trial? (0=no, 1=yes)&amp;#10;        self.rt = []  # response time(s)&amp;#10;        self.clock = psychopy.core.Clock()  # we'll use this to measure the rt&amp;#10;&amp;#10;&amp;#10;[docs]def clearEvents(eventType=None):&amp;#10;    &quot;&quot;&quot;Clears all events currently in the event buffer.&amp;#10;&amp;#10;    Optional argument, eventType, specifies only certain types to be&amp;#10;    cleared.&amp;#10;&amp;#10;    :Parameters:&amp;#10;        eventType : **None**, 'mouse', 'joystick', 'keyboard'&amp;#10;            If this is not None then only events of the given type are cleared&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    if not havePygame or not display.get_init():  # pyglet&amp;#10;        # For each window, dispatch its events before&amp;#10;        # checking event buffer.&amp;#10;        if havePyglet:&amp;#10;            for win in pyglet.app.windows:&amp;#10;                win.dispatch_events()  # pump events on pyglet windows&amp;#10;&amp;#10;        if haveGLFW:&amp;#10;            glfw.poll_events()&amp;#10;&amp;#10;        if eventType == 'mouse':&amp;#10;            pass&amp;#10;        elif eventType == 'joystick':&amp;#10;            pass&amp;#10;        else:  # eventType='keyboard' or eventType=None.&amp;#10;            global _keyBuffer&amp;#10;            _keyBuffer = []&amp;#10;    else:  # pygame&amp;#10;        if eventType == 'mouse':&amp;#10;            evt.get([locals.MOUSEMOTION, locals.MOUSEBUTTONUP,&amp;#10;                     locals.MOUSEBUTTONDOWN])&amp;#10;        elif eventType == 'keyboard':&amp;#10;            evt.get([locals.KEYDOWN, locals.KEYUP])&amp;#10;        elif eventType == 'joystick':&amp;#10;            evt.get([locals.JOYAXISMOTION, locals.JOYBALLMOTION,&amp;#10;                     locals.JOYHATMOTION, locals.JOYBUTTONUP,&amp;#10;                     locals.JOYBUTTONDOWN])&amp;#10;        else:&amp;#10;            evt.get()&amp;#10;&amp;#10;&amp;#10;class _GlobalEventKeys(MutableMapping):&amp;#10;    &quot;&quot;&quot;&amp;#10;     Global event keys for the pyglet backend.&amp;#10;&amp;#10;     Global event keys are single keys (or combinations of a single key&amp;#10;     and one or more &quot;modifier&quot; keys such as Ctrl, Alt, etc.) with an&amp;#10;     associated Python callback function. This function will be executed&amp;#10;     if the key (or key/modifiers combination) was pressed.&amp;#10;&amp;#10;     PsychoPy fully automatically monitors and processes key presses&amp;#10;     during most portions of the experimental run, for example during&amp;#10;     `core.wait()` periods, or when calling `win.flip()`. If a global&amp;#10;     event key press is detected, the specified function will be run&amp;#10;     immediately. You are not required to manually poll and check for key&amp;#10;     presses. This can be particularly useful to implement a global&amp;#10;     &quot;shutdown&quot; key, or to trigger laboratory equipment on a key press&amp;#10;     when testing your experimental script -- without cluttering the code.&amp;#10;     But of course the application is not limited to these two scenarios.&amp;#10;     In fact, you can associate any Python function with a global event key.&amp;#10;&amp;#10;     The PsychoPy preferences for `shutdownKey` and `shutdownKeyModifiers`&amp;#10;     (both unset by default) will be used to automatically create a global&amp;#10;     shutdown key once the `psychopy.event` module is being imported.&amp;#10;&amp;#10;     :Notes:&amp;#10;&amp;#10;     All keyboard -&gt; event associations are stored in the `self._events`&amp;#10;     OrderedDict. The dictionary keys are namedtuples with the elements&amp;#10;     `key` and `mofifiers`. `key` is a string defining an (ordinary)&amp;#10;     keyboard key, and `modifiers` is a tuple of modifier key strings,&amp;#10;     e.g., `('ctrl', 'alt')`. The user does not access this attribute&amp;#10;     directly, but should index the class instance itself (via&amp;#10;     `globalKeys[key, modifiers]`). That way, the `modifiers` sequence&amp;#10;     will be transparently converted into a tuple (which is a hashable&amp;#10;     type) before trying to index `self._events`.&amp;#10;&amp;#10;     &quot;&quot;&quot;&amp;#10;    _GlobalEvent = namedtuple(&amp;#10;        '_GlobalEvent',&amp;#10;        ['func', 'func_args', 'func_kwargs', 'name'])&amp;#10;&amp;#10;    _IndexKey = namedtuple('_IndexKey', ['key', 'modifiers'])&amp;#10;&amp;#10;    _valid_keys = set(string.ascii_lowercase + string.digits&amp;#10;                      + string.punctuation + ' \t')&amp;#10;    _valid_keys.update(['escape', 'left', 'right', 'up', 'down', 'space'])&amp;#10;&amp;#10;    _valid_modifiers = {'shift', 'ctrl', 'alt', 'capslock',&amp;#10;                        'scrolllock', 'command', 'option', 'windows'}&amp;#10;&amp;#10;    def __init__(self):&amp;#10;        super(_GlobalEventKeys, self).__init__()&amp;#10;        self._events = OrderedDict()&amp;#10;&amp;#10;        if prefs.general['shutdownKey']:&amp;#10;            msg = ('Found shutdown key definition in preferences; '&amp;#10;                   'enabling shutdown key.')&amp;#10;            logging.info(msg)&amp;#10;            self.add(key=prefs.general['shutdownKey'],&amp;#10;                     modifiers=prefs.general['shutdownKeyModifiers'],&amp;#10;                     func=psychopy.core.quit,&amp;#10;                     name='shutdown (auto-created from prefs)')&amp;#10;&amp;#10;    def __repr__(self):&amp;#10;        info = ''&amp;#10;        for index_key, event in list(self._events.items()):&amp;#10;            info += '\n\t'&amp;#10;            if index_key.modifiers:&amp;#10;                _modifiers = ['[%s]' % m.upper() for m in index_key.modifiers]&amp;#10;                info += '%s + ' % ' + '.join(_modifiers)&amp;#10;            info += (&quot;[%s] -&gt; '%s' %s&quot;&amp;#10;                     % (index_key.key.upper(), event.name, event.func))&amp;#10;&amp;#10;        return '&lt;_GlobalEventKeys : %s\n&gt;' % info&amp;#10;&amp;#10;    def __str__(self):&amp;#10;        return ('&lt;_GlobalEventKeys : %i key-&gt;event mappings defined.&gt;'&amp;#10;                % len(self))&amp;#10;&amp;#10;    def __len__(self):&amp;#10;        return len(self._events)&amp;#10;&amp;#10;    def __getitem__(self, key):&amp;#10;        index_key = self._gen_index_key(key)&amp;#10;        return self._events[index_key]&amp;#10;&amp;#10;    def __setitem__(self, key, value):&amp;#10;        msg = 'Please use `.add()` to add a new global event key.'&amp;#10;        raise NotImplementedError(msg)&amp;#10;&amp;#10;    def __delitem__(self, key):&amp;#10;        index_key = self._gen_index_key(key)&amp;#10;        event = self._events.pop(index_key, None)&amp;#10;&amp;#10;        if event is None:&amp;#10;            msg = 'Requested to remove unregistered global event key.'&amp;#10;            raise KeyError(msg)&amp;#10;        else:&amp;#10;            logging.exp(&quot;Removed global key event: '%s'.&quot; % event.name)&amp;#10;&amp;#10;    def __iter__(self):&amp;#10;        return iter(self._events.keys())&amp;#10;&amp;#10;    def _gen_index_key(self, key):&amp;#10;        if isinstance(key, str):  # Single key, passed as a string.&amp;#10;            index_key = self._IndexKey(key, ())&amp;#10;        else:  # Convert modifiers into a hashable type.&amp;#10;            index_key = self._IndexKey(key[0], tuple(key[1]))&amp;#10;&amp;#10;        return index_key&amp;#10;&amp;#10;    def add(self, key, func, func_args=(), func_kwargs=None,&amp;#10;            modifiers=(), name=None):&amp;#10;        &quot;&quot;&quot;&amp;#10;        Add a global event key.&amp;#10;&amp;#10;        :Parameters:&amp;#10;&amp;#10;        key : string&amp;#10;            The key to add.&amp;#10;&amp;#10;        func : function&amp;#10;            The function to invoke once the specified keys were pressed.&amp;#10;&amp;#10;        func_args : iterable&amp;#10;            Positional arguments to be passed to the specified function.&amp;#10;&amp;#10;        func_kwargs : dict&amp;#10;            Keyword arguments to be passed to the specified function.&amp;#10;&amp;#10;        modifiers : collection of strings&amp;#10;            Modifier keys. Valid keys are:&amp;#10;            'shift', 'ctrl', 'alt' (not on macOS), 'capslock',&amp;#10;            'scrolllock', 'command' (macOS only), 'option' (macOS only)&amp;#10;&amp;#10;            Num Lock is not supported.&amp;#10;&amp;#10;        name : string&amp;#10;            The name of the event. Will be used for logging. If None,&amp;#10;            will use the name of the specified function.&amp;#10;&amp;#10;        :Raises:&amp;#10;&amp;#10;        ValueError&amp;#10;            If the specified key or modifiers are invalid, or if the&amp;#10;            key / modifier combination has already been assigned to a global&amp;#10;            event.&amp;#10;&amp;#10;        &quot;&quot;&quot;&amp;#10;        if key not in self._valid_keys:&amp;#10;            raise ValueError('Unknown key specified: %s' % key)&amp;#10;&amp;#10;        if not set(modifiers).issubset(self._valid_modifiers):&amp;#10;            raise ValueError('Unknown modifier key specified.')&amp;#10;&amp;#10;        index_key = self._gen_index_key((key, modifiers))&amp;#10;        if index_key in self._events:&amp;#10;            msg = ('The specified key is already assigned to a global event. '&amp;#10;                   'Use `.remove()` to remove it first.')&amp;#10;            raise ValueError(msg)&amp;#10;&amp;#10;        if func_kwargs is None:&amp;#10;            func_kwargs = {}&amp;#10;        if name is None:&amp;#10;            name = func.__name__&amp;#10;&amp;#10;        self._events[index_key] = self._GlobalEvent(func, func_args,&amp;#10;                                                    func_kwargs, name)&amp;#10;        logging.exp('Added new global key event: %s' % name)&amp;#10;&amp;#10;    def remove(self, key, modifiers=()):&amp;#10;        &quot;&quot;&quot;&amp;#10;        Remove a global event key.&amp;#10;&amp;#10;        :Parameters:&amp;#10;&amp;#10;        key : string&amp;#10;            A single key name. If `'all'`, remove all event keys.&amp;#10;&amp;#10;        modifiers : collection of strings&amp;#10;            Modifier keys. Valid keys are:&amp;#10;            'shift', 'ctrl', 'alt' (not on macOS), 'capslock', 'numlock',&amp;#10;            'scrolllock', 'command' (macOS only), 'option' (macOS only),&amp;#10;            'windows' (Windows only)&amp;#10;&amp;#10;        &quot;&quot;&quot;&amp;#10;        if key == 'all':&amp;#10;            self._events = OrderedDict()&amp;#10;            logging.exp('Removed all global key events.')&amp;#10;            return&amp;#10;&amp;#10;        del self[key, modifiers]&amp;#10;&amp;#10;&amp;#10;def _onGLFWKey(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;Callback for key/character events for the GLFW backend.&amp;#10;&amp;#10;    :return:&amp;#10;    &quot;&quot;&quot;&amp;#10;    keyTime = psychopy.core.getTime()  # get timestamp&amp;#10;&amp;#10;    # TODO - support for key emulation&amp;#10;    win_ptr, key, scancode, action, modifiers = args&amp;#10;&amp;#10;    # only send events for PRESS and REPEAT to match pyglet behavior&amp;#10;    if action == glfw.RELEASE:&amp;#10;        return&amp;#10;&amp;#10;    global useText&amp;#10;    &amp;#10;    if key == glfw.KEY_UNKNOWN:&amp;#10;        useText = True&amp;#10;        return&amp;#10;    useText = False&amp;#10;&amp;#10;    # get the printable name, always make lowercase&amp;#10;    key_name = glfw.get_key_name(key, scancode)&amp;#10;&amp;#10;    # if there is no localized key name or space&amp;#10;    if key_name is None or key_name == ' ':&amp;#10;        try:&amp;#10;            key_name = _glfw_keycodes_[key]&amp;#10;        except KeyError:&amp;#10;            pass&amp;#10;    else:&amp;#10;        key_name = key_name.lower()&amp;#10;&amp;#10;    # TODO - modifier integration&amp;#10;    keySource = 'Keypress'&amp;#10;    _keyBuffer.append((key_name, modifiers, keyTime))  # tuple&amp;#10;    logging.data(&quot;%s: %s&quot; % (keySource, key_name))&amp;#10;&amp;#10;&amp;#10;def _onGLFWText(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;Handle unicode character events if _onGLFWKey() cannot.&amp;#10;&amp;#10;    :return:&amp;#10;    &quot;&quot;&quot;&amp;#10;    keyTime = psychopy.core.getTime()  # get timestamp&amp;#10;&amp;#10;&amp;#10;&amp;#10;    # TODO - support for key emulation&amp;#10;    win_ptr, codepoint, modifiers = args&amp;#10;    # win = glfw.get_window_user_pointer(win_ptr)&amp;#10;    text = chr(codepoint)  # convert to unicode character (Python 3.0)&amp;#10;    global useText&amp;#10;    if not useText:  # _onPygletKey has handled the input&amp;#10;        return&amp;#10;    keySource = 'KeyPress'&amp;#10;    _keyBuffer.append((text, keyTime))&amp;#10;    logging.data(&quot;%s: %s&quot; % (keySource, text))&amp;#10;&amp;#10;&amp;#10;def _onGLFWMouseButton(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;Callback for mouse press events. Both press and release actions are&amp;#10;    handled by this function as they both invoke the same callback.&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    global mouseButtons, mouseClick, mouseTimes&amp;#10;    now = psychopy.core.getTime()&amp;#10;    win_ptr, button, action, modifier = args&amp;#10;    # win = glfw.get_window_user_pointer(win_ptr)&amp;#10;&amp;#10;    # get current position of the mouse&amp;#10;    # this might not be at the exact location of the mouse press&amp;#10;    x, y = glfw.get_cursor_pos(win_ptr)&amp;#10;&amp;#10;    # process actions&amp;#10;    if action == glfw.PRESS:&amp;#10;        if button == glfw.MOUSE_BUTTON_LEFT:&amp;#10;            mouseButtons[0] = 1&amp;#10;            mouseTimes[0] = now - mouseClick[0].getLastResetTime()&amp;#10;        elif button == glfw.MOUSE_BUTTON_MIDDLE:&amp;#10;            mouseButtons[1] = 1&amp;#10;            mouseTimes[1] = now - mouseClick[1].getLastResetTime()&amp;#10;        elif button == glfw.MOUSE_BUTTON_RIGHT:&amp;#10;            mouseButtons[2] = 1&amp;#10;            mouseTimes[2] = now - mouseClick[2].getLastResetTime()&amp;#10;    elif action == glfw.RELEASE:&amp;#10;        if button == glfw.MOUSE_BUTTON_LEFT:&amp;#10;            mouseButtons[0] = 0&amp;#10;        elif button == glfw.MOUSE_BUTTON_MIDDLE:&amp;#10;            mouseButtons[1] = 0&amp;#10;        elif button == glfw.MOUSE_BUTTON_RIGHT:&amp;#10;            mouseButtons[2] = 0&amp;#10;&amp;#10;&amp;#10;def _onGLFWMouseScroll(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;Callback for mouse scrolling events. For most computer mice with scroll&amp;#10;    wheels, only the vertical (Y-offset) is relevant.&amp;#10;&amp;#10;    &quot;&quot;&quot;&amp;#10;    window_ptr, x_offset, y_offset = args&amp;#10;    global mouseWheelRel&amp;#10;    mouseWheelRel = mouseWheelRel + numpy.array([x_offset, y_offset])&amp;#10;    msg = &quot;Mouse: wheel shift=(%i,%i)&quot;&amp;#10;    logging.data(msg % (x_offset, y_offset))&amp;#10;&amp;#10;&amp;#10;def _getGLFWJoystickButtons(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;&amp;#10;    :return:&amp;#10;    &quot;&quot;&quot;&amp;#10;    pass&amp;#10;&amp;#10;&amp;#10;def _getGLFWJoystickAxes(*args, **kwargs):&amp;#10;    &quot;&quot;&quot;&amp;#10;    :return:&amp;#10;    &quot;&quot;&quot;&amp;#10;    pass&amp;#10;&amp;#10;&amp;#10;if havePyglet:&amp;#10;    globalKeys = _GlobalEventKeys()" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="stimParams" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="loadImages" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="#imageFilePath&amp;#10;imageFilePath =&quot;C:/Users/cocon/OneDrive/Documents/GitHub/psychedeLightsExpCode/&quot;#'C:/Users/ipmmz/Desktop/psychedeLights_psychopy/'#&amp;#10;&amp;#10;" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="loadImages" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="ITI">
      <RoutineSettingsComponent name="ITI" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="ITI" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="elRecord_iti" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;itiStart&quot;, aaa().toString());&amp;#10;this_epoch = &quot;ITI&quot;;&amp;#10;if ((eyetracking === 1)) {&amp;#10;    el_tracker.sendMessage(&quot;ITI&quot;);&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData('itiStart',str(aaa()))&amp;#10;this_epoch = 'ITI'&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    el_tracker.sendMessage('ITI')" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Auto-&gt;JS" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;itiEnd&quot;, aaa().toString());&amp;#10;if ((eyetracking === 1)) {&amp;#10;    el_tracker.sendMessage(&quot;trialEnd&quot;);&amp;#10;    el_tracker.sendMessage(`!V TRIAL_VAR TRIALID ${trlId.toString()}`);&amp;#10;    el_tracker.stopRecording();&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData('itiEnd',str(aaa()))&amp;#10;if eyetracking == 1:&amp;#10;   &amp;#10;    el_tracker.sendMessage('trialEnd')&amp;#10;    el_tracker.sendMessage('!V TRIAL_VAR TRIALID %s'% str(trlId))&amp;#10;    el_tracker.stopRecording()&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_iti" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="resets" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#add 1 to total trl count&amp;#10;trlCntTotal +=1&amp;#10;trlCntThisBlk +=1&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= itiT:&amp;#10;    key = kb.getKeys([ 'escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;          core.quit()" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="resets" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="trlInit">
      <RoutineSettingsComponent name="trlInit" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="trlInit" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="initTrlParams" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="trlCntTotal += 1;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="&quot;&quot;&quot;create trial id&quot;&quot;&quot;&amp;#10;trlId = (expInfo['participant'],trlCntThisBlk,expBlk.thisN)&amp;#10;&amp;#10;&quot;&quot;&quot;cue related params&quot;&quot;&quot;&amp;#10;cueCircColor.fillColor = cueColDefault&amp;#10;&amp;#10;&quot;&quot;&quot;distractor related params&quot;&quot;&quot;&amp;#10;distractorType = None&amp;#10;distractorCtrl = 1 #default add distractor&amp;#10;visualDistractor.opacity = 0&amp;#10;categoricalDistractor.setOpacity(0)&amp;#10;if distractorArr[trlCntTotal] == 0: #no distactor&amp;#10;    distractorCtrl = 0&amp;#10;    distractorType = (False,'noDistractor',None)&amp;#10;elif distractorArr[trlCntTotal] == 1: #visual&amp;#10;    visualDistractor.setImage(distractorPath[trlCntTotal])&amp;#10;    visualDistractor.opacity = 1&amp;#10;    distractorType = (True,'visual',distractorPath[trlCntTotal].split(os.sep)[-1])&amp;#10;else: #categorical&amp;#10;    categoricalDistractor.text = distractorPath[trlCntTotal]&amp;#10;    categoricalDistractor.setOpacity(1)&amp;#10;    distractorType = (True,'categorical',distractorPath[trlCntTotal])&amp;#10;&amp;#10;&quot;&quot;&quot;probe related params&quot;&quot;&quot;&amp;#10;np.random.shuffle(probePosArr)&amp;#10;#set the probe images this trial&amp;#10;if trlType[trlCntTotal] == 0: #if visual trial, set visual probe&amp;#10;    trlTypeThis = 'visual'&amp;#10;    cueCorThis = cueColArr[0]&amp;#10;&amp;#10;    #the following params are used for indexing &amp;#10;    a = trlCntTotal*sum(relatedProbeNum)&amp;#10;    b = trlCntTotal*sum(relatedProbeNum)+sum(relatedProbeNum)&amp;#10;    &amp;#10;    #grab the position params for different probes.&amp;#10;    corrPos = probePosArr[0]&amp;#10;    distractorPos = probePosArr[1]&amp;#10;    relPos = probePosArr[2:2+sum(relatedProbeNum)]&amp;#10;    distractorRelPos = probePosArr[2+sum(relatedProbeNum):2+sum(relatedProbeNum)+sum(relatedProbeNum)]&amp;#10;&amp;#10;    #get all probe items&amp;#10;    corrProbeArr.setImage(corrProbePath[trlCntTotal])&amp;#10;    distractorProbeArr.setImage(distractorProbePath[trlCntTotal])&amp;#10;    clickables = [corrProbeArr,distractorProbeArr]&amp;#10;&amp;#10;    #set position&amp;#10;    corrProbeArr.setPos(corrPos)&amp;#10;    distractorProbeArr.setPos(distractorPos)&amp;#10;&amp;#10;    for n,(i,p) in enumerate(zip(relProbePath[a:b],relPos)):&amp;#10;        relProbeArr[n].setImage(i)&amp;#10;        clickables.append(relProbeArr[n])&amp;#10;        relProbeArr[n].setPos(p)&amp;#10;    for n,(i,p) in enumerate(zip(distractorRelProbePath[a:b],distractorRelPos)):&amp;#10;        distractorRelProbeArr[n].setImage(i)&amp;#10;        clickables.append(distractorRelProbeArr[n])&amp;#10;        distractorRelProbeArr[n].setPos(p)&amp;#10;    for i in clickables:&amp;#10;        i.size = i.size*visualProbeSizeScalar&amp;#10;else: #if categorical trial, set categorical probe&amp;#10;    trlTypeThis = 'categorical'&amp;#10;    cueCorThis = cueColArr[1]&amp;#10;    &amp;#10;    #the following params are used for indexing &amp;#10;    a = trlCntTotal*5&amp;#10;    b = trlCntTotal*5+5&amp;#10;    &amp;#10;    corrPos = probePosArr[0]&amp;#10;    incorrPos = probePosArr[1:]&amp;#10;    &amp;#10;    #get all probe items&amp;#10;    corrCatProbeArr.setImage(corrCatProbePath[trlCntTotal])&amp;#10;    corrCatProbeArr.setPos(corrPos)&amp;#10;    clickables = [corrCatProbeArr]&amp;#10;    &amp;#10;    for n,(i,p) in enumerate(zip(incorrCatProbePath[a:b],incorrPos)):&amp;#10;        incorrCatProbeArr[n].setImage(i)&amp;#10;        clickables.append(incorrCatProbeArr[n])&amp;#10;        incorrCatProbeArr[n].setPos(p)&amp;#10;    for i in clickables:&amp;#10;        i.size = i.size/visualProbeSizeScalar&amp;#10;clickables = np.asarray(clickables)&amp;#10; " valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="thisExp.addData('TRIALID',trlId)&amp;#10;thisExp.addData('trlType',trlTypeThis)&amp;#10;thisExp.addData('distractor',distractorType)" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="initTrlParams" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="retrocue">
      <RoutineSettingsComponent name="retrocue" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="retrocue" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drawRetrocue" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="retrocueMask.ori = cueArr[trlCntTotal]&amp;#10;&amp;#10;cueCircColor.colorSpace='rgb255'&amp;#10;cueCircColor.color = cueCorThis&amp;#10;cueCircColor.setAutoDraw(True)&amp;#10;retrocueMask.setAutoDraw(True) #draw retrocue&amp;#10;&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= retrocueT:&amp;#10;    key = kb.getKeys(['space', 'escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;          core.quit()" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="cueCircColor.setAutoDraw(False)&amp;#10;retrocueMask.setAutoDraw(False)&amp;#10;&amp;#10;thisExp.addData('cueDirection',cueArrLabel[trlCntTotal])&amp;#10;thisExp.addData('cuedItem',cuedImageBri[trlCntTotal])&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawRetrocue" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_retrocue" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'retrocue'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    #el_tracker.startRecording(1, 1, 1, 1)&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_retrocue" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="blkInit">
      <RoutineSettingsComponent name="blkInit" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="blkInit" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="initBlkParams" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="trlCntThisBlk = 0" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="initBlkParams" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="IBI">
      <RoutineSettingsComponent name="IBI" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="IBI" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <TextComponent name="text" plugin="None">
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="False" valType="code" updates="constant" name="draggable"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.05" valType="num" updates="constant" name="letterHeight"/>
        <Param val="text" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="you've reached the end of this block, press space when you're ready to continue" valType="str" updates="constant" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
      <KeyboardComponent name="ibiSpace" plugin="None">
        <Param val="'space'" valType="list" updates="constant" name="allowedKeys"/>
        <Param val="" valType="str" updates="constant" name="correctAns"/>
        <Param val="" valType="str" updates="None" name="deviceLabel"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="True" valType="bool" updates="constant" name="discard previous"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="ibiSpace" valType="code" updates="None" name="name"/>
        <Param val="press" valType="str" updates="constant" name="registerOn"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="last key" valType="str" updates="constant" name="store"/>
        <Param val="False" valType="bool" updates="constant" name="storeCorrect"/>
        <Param val="True" valType="bool" updates="constant" name="syncScreenRefresh"/>
      </KeyboardComponent>
    </Routine>
    <Routine name="delay">
      <RoutineSettingsComponent name="delay" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="delay" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="delayCode" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="imageFilePath = &quot;C:/Users/ipmmz/Desktop/psychedeLights_psychopy/&quot;;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="cueCircColor.setAutoDraw(True)&amp;#10;fixCircMask.setAutoDraw(True)&amp;#10;noisePatchRight.setAutoDraw(False)&amp;#10;noisePatchLeft.setAutoDraw(False)&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= noDistractorDelayT:&amp;#10;&amp;#10;    key = kb.getKeys(['escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;        core.quit()&amp;#10;        &amp;#10;cueCircColor.setAutoDraw(False)&amp;#10;fixCircMask.setAutoDraw(False)&amp;#10;&amp;#10;&amp;#10;while (clock.getTime() &gt;= noDistractorDelayT) &amp; (distractorCtrl == 1) &amp; (clock.getTime() &lt; noDistractorDelayT + distractorT):&amp;#10;    visualDistractor.setAutoDraw(True)&amp;#10;    categoricalDistractor.setAutoDraw(True)&amp;#10;    win.flip()&amp;#10;    &amp;#10;cueCircColor.setAutoDraw(True)&amp;#10;fixCircMask.setAutoDraw(True)&amp;#10;visualDistractor.setAutoDraw(False)&amp;#10;categoricalDistractor.setAutoDraw(False)&amp;#10;win.flip()&amp;#10;&amp;#10;while (clock.getTime() &lt; delayT):&amp;#10;    pass&amp;#10;" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="noisePatchRight.setAutoDraw(False)&amp;#10;noisePatchLeft.setAutoDraw(False)&amp;#10;&amp;#10;fixCircMask.setAutoDraw(False)&amp;#10;cueCircColor.setAutoDraw(False)&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="delayCode" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_delay" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'delay'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    #el_tracker.startRecording(1, 1, 1, 1)&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_delay" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="preCueRest">
      <RoutineSettingsComponent name="preCueRest" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="preCueRest" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drawNoise" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="imageFilePath = &quot;C:/Users/ipmmz/Desktop/psychedeLights_psychopy/&quot;;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="noisePatchRight.setAutoDraw(True)&amp;#10;noisePatchLeft.setAutoDraw(True)&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= noisePatchT:&amp;#10;    key = kb.getKeys(['escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;          core.quit()&amp;#10;noisePatchRight.setAutoDraw(False)&amp;#10;noisePatchLeft.setAutoDraw(False)&amp;#10;win.flip()&amp;#10;&amp;#10;while clock.getTime() &lt;= preCueRestT:&amp;#10;    pass&amp;#10;" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="cueCircColor.setAutoDraw(False)&amp;#10;fixCircMask.setAutoDraw(False)&amp;#10;&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawNoise" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_preCue" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'preCueRest'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    #el_tracker.startRecording(1, 1, 1, 1)&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_preCue" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="connectEL">
      <RoutineSettingsComponent name="connectEL" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="connectEL" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="connectTracker" plugin="None">
        <Param val="import platform&amp;#10;from PIL import Image  # for preparing the Host backdrop image&amp;#10;from string import ascii_letters&amp;#10;import time&amp;#10;&amp;#10;# import eyelink libs&amp;#10;import pylink&amp;#10;from EyeLinkCoreGraphicsPsychoPy import EyeLinkCoreGraphicsPsychoPy&amp;#10;&amp;#10;" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="# this is adapted from the SR research's eyelink tutorial code&amp;#10;#parameters to change&amp;#10;calib_style = 13 #9 for head fixed, 13 for remote &amp;#10;samprate = 1000 #250, 500, 1000, or 2000&amp;#10;calib_tar_size = 24 #size for the calibration target&amp;#10;&amp;#10;&quot;&quot;&quot;change this&quot;&quot;&quot;&amp;#10;width_param = 53.0 &amp;#10;distance_param =70.0&amp;#10;&amp;#10;&amp;#10;#create a folder to store all edf files, call this folder 'results'&amp;#10;edf_folder = 'C:/Users/yud070/Documents/elRaw'&amp;#10;if not os.path.exists(edf_folder):&amp;#10;    os.makedirs(edf_folder)&amp;#10;&amp;#10;# We download EDF data file from the EyeLink Host PC to the local hard&amp;#10;# drive at the end of each testing session, here we rename the EDF to&amp;#10;# include session start date/time&amp;#10;time_str = time.strftime(&quot;_%Y_%m_%d_%H_%M&quot;, time.localtime())&amp;#10;session_identifier = str(expInfo['participant']) + time_str&amp;#10;&amp;#10;# create a folder for the current testing session in the &quot;results&quot; folder&amp;#10;session_folder = os.path.join(edf_folder, session_identifier)&amp;#10;if not os.path.exists(session_folder):&amp;#10;    os.makedirs(session_folder)&amp;#10;&amp;#10;&amp;#10;#helper function for displaying text&amp;#10;def clear_screen(win):&amp;#10;    &quot;&quot;&quot; clear up the PsychoPy window&quot;&quot;&quot;&amp;#10;&amp;#10;    win.fillColor = genv.getBackgroundColor()&amp;#10;    win.flip()&amp;#10;def show_msg(win, text, wait_for_keypress=True):&amp;#10;    &quot;&quot;&quot; Show task instructions on screen&quot;&quot;&quot;&amp;#10;&amp;#10;    msg = visual.TextStim(win, text,&amp;#10;                          color=genv.getForegroundColor(),&amp;#10;                          wrapWidth=scn_width/2)&amp;#10;    clear_screen(win)&amp;#10;    msg.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # wait indefinitely, terminates upon any key press&amp;#10;    if wait_for_keypress:&amp;#10;        event.waitKeys(keyList = ['space','escape'],maxWait = 60)&amp;#10;        clear_screen(win)&amp;#10;     &amp;#10;#function to terminate task and retrieve the EDF data file from the host PC and &amp;#10;#download to the display pc&amp;#10;def terminate_task():&amp;#10;    el_tracker = pylink.getEYELINK()&amp;#10;&amp;#10;    if el_tracker.isConnected():&amp;#10;&amp;#10;        # Put tracker in Offline mode&amp;#10;        el_tracker.setOfflineMode()&amp;#10;&amp;#10;        # Clear the Host PC screen and wait for 500 ms&amp;#10;        el_tracker.sendCommand('clear_screen 0')&amp;#10;        pylink.msecDelay(500)&amp;#10;&amp;#10;        # Close the edf data file on the Host&amp;#10;        el_tracker.closeDataFile()&amp;#10;&amp;#10;        # Show a file transfer message on the screen&amp;#10;        msg = 'EDF data is transferring from EyeLink Host PC...'&amp;#10;        show_msg(win, msg, wait_for_keypress=False)&amp;#10;&amp;#10;        # Download the EDF data file from the Host PC to a local data folder&amp;#10;        # parameters: source_file_on_the_host, destination_file_on_local_drive&amp;#10;        local_edf = os.path.join(session_folder, session_identifier + '.EDF')&amp;#10;        try:&amp;#10;            el_tracker.receiveDataFile(edf_file, local_edf)&amp;#10;        except RuntimeError as error:&amp;#10;            print('ERROR:', error)&amp;#10;&amp;#10;        # Close the link to the tracker.&amp;#10;        el_tracker.close()&amp;#10;&amp;#10;    # close the PsychoPy window&amp;#10;    win.close()&amp;#10;&amp;#10;    # quit PsychoPy&amp;#10;    core.quit()&amp;#10;    sys.exit()&amp;#10;    &amp;#10;def abort_trial():&amp;#10;    &quot;&quot;&quot;Ends recording &quot;&quot;&quot;&amp;#10;&amp;#10;    el_tracker = pylink.getEYELINK()&amp;#10;&amp;#10;    # Stop recording&amp;#10;    if el_tracker.isRecording():&amp;#10;        # add 100 ms to catch final trial events&amp;#10;        pylink.pumpDelay(100)&amp;#10;        el_tracker.stopRecording()&amp;#10;&amp;#10;    # clear the screen&amp;#10;    clear_screen(win)&amp;#10;    # Send a message to clear the Data Viewer screen&amp;#10;    bgcolor_RGB = (116, 116, 116)&amp;#10;    el_tracker.sendMessage('!V CLEAR %d %d %d' % bgcolor_RGB)&amp;#10;&amp;#10;    # send a message to mark trial end&amp;#10;    el_tracker.sendMessage('TRIAL_RESULT %d' % pylink.TRIAL_ERROR)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="# Step 1: Connect to the EyeLink Host PC&amp;#10;host_ip = &quot;100.1.1.1&quot;&amp;#10;if eyetracking == 1:&amp;#10;    try:&amp;#10;        el_tracker = pylink.EyeLink(host_ip)&amp;#10;    except RuntimeError as error:&amp;#10;        print('ERROR:', error)&amp;#10;        core.quit()&amp;#10;        sys.exit()&amp;#10;    &amp;#10;    # Step 2: Open an EDF data file on the Host PC&amp;#10;    edf_file = str(expInfo['participant']) + &quot;.EDF&quot;&amp;#10;    try:&amp;#10;        el_tracker.openDataFile(edf_file)&amp;#10;    except RuntimeError as err:&amp;#10;        print('ERROR:', err)&amp;#10;        # close the link if we have one open&amp;#10;        if el_tracker.isConnected():&amp;#10;            el_tracker.close()&amp;#10;        core.quit()&amp;#10;        sys.exit()&amp;#10;&amp;#10;    # Step 3: Configure the tracker&amp;#10;    # Put the tracker in offline mode before we change tracking parameters&amp;#10;    el_tracker.setOfflineMode()&amp;#10;    # File and Link data control&amp;#10;    # what eye events to save in the EDF file, include everything by default&amp;#10;    file_event_flags = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT'&amp;#10;    file_sample_flags = 'LEFT,RIGHT,GAZE,GAZERES,HREF,RAW,PUPIL,AREA,HTARGET,STATUS,INPUT'&amp;#10;    # what eye events to make available over the link, include everything by default&amp;#10;    link_event_flags = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,BUTTON,FIXUPDATE,INPUT'&amp;#10;    link_sample_flags = 'LEFT,RIGHT,GAZE,GAZERES,AREA,HTARGET,STATUS,INPUT'&amp;#10;    el_tracker.sendCommand(&quot;file_event_filter = %s&quot; % file_event_flags)&amp;#10;    el_tracker.sendCommand(&quot;file_sample_data = %s&quot; % file_sample_flags)&amp;#10;    el_tracker.sendCommand(&quot;link_event_filter = %s&quot; % link_event_flags)&amp;#10;    el_tracker.sendCommand(&quot;link_sample_data = %s&quot; % link_sample_flags)&amp;#10;    #set calibration style&amp;#10;    el_tracker.sendCommand(&quot;calibration_type = HV%s&quot; % str(calib_style))&amp;#10;    #set sampling rate&amp;#10;    el_tracker.sendCommand(&quot;sample_rate %s&quot; % str(samprate))&amp;#10; &amp;#10;    # Step 4: set up a graphics environment for calibration&amp;#10;    # get the native screen resolution used by PsychoPy&amp;#10;    scn_width, scn_height = win.size&amp;#10;    # resolution fix for Mac retina displays&amp;#10;    if 'Darwin' in platform.system():&amp;#10;        if use_retina:&amp;#10;            scn_width = int(scn_width/2.0)&amp;#10;            scn_height = int(scn_height/2.0)&amp;#10;    # Pass the display pixel coordinates (left, top, right, bottom) to the tracker&amp;#10;    el_coords = &quot;screen_pixel_coords = 0 0 %d %d&quot; % (scn_width - 1, scn_height - 1)&amp;#10;    el_tracker.sendCommand(el_coords)&amp;#10;    # Write a DISPLAY_COORDS message to the EDF file&amp;#10;    # Data Viewer needs this piece of info for proper visualization&amp;#10;    dv_coords = &quot;DISPLAY_COORDS  0 0 %d %d&quot; % (scn_width - 1, scn_height - 1)&amp;#10;    el_tracker.sendMessage(dv_coords)&amp;#10;    # Configure a graphics environment (genv) for tracker calibration&amp;#10;    genv = EyeLinkCoreGraphicsPsychoPy(el_tracker, win)&amp;#10;    # Set background and foreground colors for the calibration target&amp;#10;    # in PsychoPy, (-1, -1, -1)=black, (1, 1, 1)=white, (0, 0, 0)=mid-gray&amp;#10;    foreground_color = (-1, -1, -1)&amp;#10;    background_color = win.color&amp;#10;    genv.setCalibrationColors(foreground_color, background_color)&amp;#10;    genv.setTargetSize(calib_tar_size)&amp;#10;    # Request Pylink to use the PsychoPy window we opened above for calibration&amp;#10;    pylink.openGraphicsEx(genv)&amp;#10;    task_msg = 'Press &lt;space&gt;, then &lt;enter&gt; to start calibration'&amp;#10;    show_msg(win, task_msg)&amp;#10;    print('line69')&amp;#10;    &amp;#10;    try:&amp;#10;        el_tracker.doTrackerSetup()&amp;#10;    except RuntimeError as err:&amp;#10;        print('ERROR:', err)&amp;#10;        el_tracker.exitCalibration()&amp;#10;else:&amp;#10;    continueRoutine = False&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="#dont record yet&amp;#10;if eyetracking == 1:&amp;#10;    el_tracker.setOfflineMode()&amp;#10;win.mouseVisible = True&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="connectTracker" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="terminateExp">
      <RoutineSettingsComponent name="terminateExp" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="terminateExp" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="closeEl" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="if ((eyetracking === 1)) {&amp;#10;    terminate_task();&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="if eyetracking == 1:&amp;#10;&amp;#10;    # Step 7: disconnect, download the EDF file, then terminate the task&amp;#10;    terminate_task()&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Auto-&gt;JS" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="closeEl" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="categoryProbe">
      <RoutineSettingsComponent name="categoryProbe" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="categoryProbe" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="elRecord_probe_cat" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'probe'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_probe_cat" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <PolygonComponent name="transparentPlaceHolder_cat" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="False" valType="code" updates="constant" name="draggable"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="0.0000, 0.0000, 0.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="linear" valType="str" updates="constant" name="interpolate"/>
        <Param val="white" valType="color" updates="constant" name="lineColor"/>
        <Param val="1" valType="num" updates="constant" name="lineWidth"/>
        <Param val="4" valType="int" updates="constant" name="nVertices"/>
        <Param val="transparentPlaceHolder_cat" valType="code" updates="None" name="name"/>
        <Param val="0" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="triangle" valType="str" updates="None" name="shape"/>
        <Param val="(0.5, 0.5)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="$probeT" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="list" updates="constant" name="vertices"/>
      </PolygonComponent>
      <CodeComponent name="drawProbe_cat" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="probeMouse = event.Mouse(newPos = (0,0))&amp;#10;" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="mouseIsDown = False&amp;#10;&amp;#10;#record continuous mouse activity&amp;#10;probeMouse.x = []&amp;#10;probeMouse.y = []&amp;#10;probeMouse.leftButton = []&amp;#10;probeMouse.midButton = []&amp;#10;probeMouse.rightButton = []&amp;#10;probeMouse.time = []&amp;#10;probeMouse.clickOn = []&amp;#10;&amp;#10;#other mouse related variables&amp;#10;eachClickTime = []&amp;#10;eachClickItem = []&amp;#10;&amp;#10;#the following params are used for indexing &amp;#10;a = trlCntTotal*sum(relatedProbeNum)&amp;#10;b = trlCntTotal*sum(relatedProbeNum)+sum(relatedProbeNum)&amp;#10;#c = trlCntTotal*sum(unreledProbeNum)&amp;#10;#d = trlCntTotal*sum(unreledProbeNum)+2&amp;#10;&amp;#10;#grab the position params for different probes.&amp;#10;corrPos = probePosArr[0]&amp;#10;distractorPos = probePosArr[1]&amp;#10;relPos = probePosArr[2:2+sum(relatedProbeNum)]&amp;#10;distractorRelPos = probePosArr[2+sum(relatedProbeNum):2+sum(relatedProbeNum)+sum(relatedProbeNum)]&amp;#10;#unrelPos = probePosArr[2+sum(relatedProbeNum):2+sum(relatedProbeNum)+sum(unreledProbeNum)]&amp;#10;&amp;#10;#get all probe items&amp;#10;clickables = [corrProbeArr[trlCntTotal],distractorProbeArr[trlCntTotal]]&amp;#10;&amp;#10;#set position&amp;#10;corrProbeArr[trlCntTotal].setPos(corrPos)&amp;#10;distractorProbeArr[trlCntTotal].setPos(distractorPos)&amp;#10;for i,p in zip(relProbeArr[a:b],relPos):&amp;#10;    clickables.append(i)&amp;#10;    i.setPos(p)&amp;#10;    i.setAutoDraw(True)&amp;#10;for i,p in zip(distractorRelProbeArr[a:b],distractorRelPos):&amp;#10;    clickables.append(i)&amp;#10;    i.setPos(p)&amp;#10;    i.setAutoDraw(True)    &amp;#10;&amp;#10;&quot;&quot;&quot;&amp;#10;for i,p in zip(unrelProbeArr[c:d],unrelPos):&amp;#10;    clickables.append(i)&amp;#10;    i.setPos(p)&amp;#10;    i.setAutoDraw(True)&amp;#10;&quot;&quot;&quot;&amp;#10;clickables = np.asarray(clickables)&amp;#10;clicksTotal = np.zeros(len(clickables))&amp;#10;clickOnClickable = np.zeros(len(clickables))&amp;#10;&amp;#10;#prepare to draw&amp;#10;corrProbeArr[trlCntTotal].setAutoDraw(True)&amp;#10;distractorProbeArr[trlCntTotal].setAutoDraw(True)&amp;#10;&amp;#10;#resets&amp;#10;clock.reset()&amp;#10;kb.clearEvents()&amp;#10;probeMouse.clickReset(buttons=(0, 1, 2))&amp;#10;event.clearEvents('mouse')&amp;#10;probeMouse.mouseClock.reset()&amp;#10;&amp;#10;#set mouse starting position&amp;#10;probeMouse.setPos((0,0))&amp;#10;probeMouse.setVisible(1)&amp;#10;&amp;#10;win.flip()&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="&amp;#10;x, y = probeMouse.getPos()&amp;#10;probeMouse.x.append(x)&amp;#10;probeMouse.y.append(y)&amp;#10;buttons = probeMouse.getPressed()&amp;#10;&amp;#10;probeMouse.leftButton.append(buttons[0])&amp;#10;probeMouse.midButton.append(buttons[1])&amp;#10;probeMouse.rightButton.append(buttons[2])&amp;#10;probeMouse.time.append(probeMouse.mouseClock.getTime())&amp;#10;&amp;#10;hoverOnClickable = np.asarray([i.contains(probeMouse) for i in clickables])&amp;#10;probeMouse.clickOn.append(hoverOnClickable)&amp;#10;&amp;#10;&amp;#10;key = kb.getKeys(['space', 'escape'], waitRelease=False)&amp;#10;if 'space' in key:&amp;#10;    continueRoutine  = False&amp;#10;if 'escape' in key:&amp;#10;    core.quit()&amp;#10;#check for mouse press&amp;#10;if sum(buttons) and mouseIsDown == False and sum(hoverOnClickable):&amp;#10;    clickOnClickable = np.where(hoverOnClickable,1,0)&amp;#10;    &amp;#10;    eachClickTime.append(probeMouse.mouseClock.getTime())&amp;#10;    eachClickItem.append(clickableLabel[np.where(clickOnClickable == 1)[0]][0])&amp;#10;    #mouse is pressing right now&amp;#10;    mouseIsDown = True&amp;#10;#check for mouse release    &amp;#10;if sum(buttons) == 0 and mouseIsDown:&amp;#10;    #mouse released&amp;#10;    clicksTotal += clickOnClickable&amp;#10;    &amp;#10;    #change opacity&amp;#10;    clicking = clickables[clickOnClickable ==1][0]&amp;#10;    &amp;#10;    #set opacity&amp;#10;    for n,i in enumerate(clickables):&amp;#10;        i.opacity = 1&amp;#10;    clicking.opacity = 0.25&amp;#10;    &amp;#10;    mouseIsDown = False" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="corrProbeArr[trlCntTotal].setAutoDraw(False)&amp;#10;distractorProbeArr[trlCntTotal].setAutoDraw(False)&amp;#10;&amp;#10;for i,p in zip(relProbeArr[a:b],relPos):&amp;#10;    i.setAutoDraw(False)&amp;#10;&amp;#10;for i,p in zip(distractorRelProbeArr[a:b],distractorRelPos):&amp;#10;    i.setAutoDraw(False)&amp;#10;&quot;&quot;&quot;&amp;#10;for i,p in zip(unrelProbeArr[a:b],unrelPos):&amp;#10;    i.setAutoDraw(False)&amp;#10;&quot;&quot;&quot;&amp;#10;win.flip()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;probeMouse.setVisible(0)&amp;#10;&amp;#10;#&amp;#10;&amp;#10;#add mouse activity&amp;#10;trials.addData('probeMouse.x', probeMouse.x)&amp;#10;trials.addData('probeMouse.y', probeMouse.y)&amp;#10;trials.addData('probeMouse.leftButton', probeMouse.leftButton)&amp;#10;trials.addData('probeMouse.midButton', probeMouse.midButton)&amp;#10;trials.addData('probeMouse.rightButton', probeMouse.rightButton)&amp;#10;trials.addData('probeMouse.time', probeMouse.time)&amp;#10;trials.addData('probeMouse.mouseOnProbes', probeMouse.clickOn)&amp;#10;&amp;#10;#add data about probe information&amp;#10;for label,path in zip(clickableLabel,clickables):&amp;#10;    thisExp.addData(label,path._imName)&amp;#10;    &amp;#10;#record position for each probe item&amp;#10;thisExp.addData('probeLocationArr',probePosArr)&amp;#10;#record the final response&amp;#10;thisExp.addData('rspIndex',clickOnClickable)&amp;#10;thisExp.addData('rsp',clickableLabel[np.where(clickOnClickable == 1)[0]][0])&amp;#10;thisExp.addData('rspPath',clickables[np.where(clickOnClickable == 1)[0]][0]._imName)&amp;#10;&amp;#10;#record RT&amp;#10;thisExp.addData('rt',eachClickTime[0])&amp;#10;thisExp.addData('timeEachClick', eachClickTime)&amp;#10;thisExp.addData('itemEachClick', eachClickItem)&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawProbe_cat" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="probe">
      <RoutineSettingsComponent name="probe" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="probe" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="elRecord_probe" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'probe'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_probe" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <PolygonComponent name="transparentPlaceHolder" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="False" valType="code" updates="constant" name="draggable"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="0.0000, 0.0000, 0.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="linear" valType="str" updates="constant" name="interpolate"/>
        <Param val="white" valType="color" updates="constant" name="lineColor"/>
        <Param val="1" valType="num" updates="constant" name="lineWidth"/>
        <Param val="4" valType="int" updates="constant" name="nVertices"/>
        <Param val="transparentPlaceHolder" valType="code" updates="None" name="name"/>
        <Param val="0" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="triangle" valType="str" updates="None" name="shape"/>
        <Param val="(0.5, 0.5)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="$probeT" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="list" updates="constant" name="vertices"/>
      </PolygonComponent>
      <CodeComponent name="drawProbe" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="probeMouse = event.Mouse(newPos = (0,0))&amp;#10;" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="mouseIsDown = False&amp;#10;&amp;#10;#record continuous mouse activity&amp;#10;probeMouse.x = []&amp;#10;probeMouse.y = []&amp;#10;probeMouse.leftButton = []&amp;#10;probeMouse.midButton = []&amp;#10;probeMouse.rightButton = []&amp;#10;probeMouse.time = []&amp;#10;probeMouse.clickOn = []&amp;#10;&amp;#10;#other mouse related variables&amp;#10;eachClickTime = []&amp;#10;eachClickItem = []&amp;#10;&amp;#10;clicksTotal = np.zeros(len(clickables))&amp;#10;clickOnClickable = np.zeros(len(clickables))&amp;#10;&amp;#10;#prepare to draw&amp;#10;for i in clickables:&amp;#10;    i.setAutoDraw(True)&amp;#10;    &amp;#10;#resets&amp;#10;clock.reset()&amp;#10;kb.clearEvents()&amp;#10;probeMouse.clickReset(buttons=(0, 1, 2))&amp;#10;event.clearEvents('mouse')&amp;#10;probeMouse.mouseClock.reset()&amp;#10;&amp;#10;#set mouse starting position&amp;#10;probeMouse.setPos((0,0))&amp;#10;probeMouse.setVisible(1)&amp;#10;&amp;#10;win.flip()&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="&amp;#10;x, y = probeMouse.getPos()&amp;#10;probeMouse.x.append(x)&amp;#10;probeMouse.y.append(y)&amp;#10;buttons = probeMouse.getPressed()&amp;#10;&amp;#10;probeMouse.leftButton.append(buttons[0])&amp;#10;probeMouse.midButton.append(buttons[1])&amp;#10;probeMouse.rightButton.append(buttons[2])&amp;#10;probeMouse.time.append(probeMouse.mouseClock.getTime())&amp;#10;&amp;#10;hoverOnClickable = np.asarray([i.contains(probeMouse) for i in clickables])&amp;#10;probeMouse.clickOn.append(hoverOnClickable)&amp;#10;&amp;#10;&amp;#10;key = kb.getKeys(['space', 'escape'], waitRelease=False)&amp;#10;if 'space' in key:&amp;#10;    continueRoutine  = False&amp;#10;if 'escape' in key:&amp;#10;    core.quit()&amp;#10;#check for mouse press&amp;#10;if sum(buttons) and mouseIsDown == False and sum(hoverOnClickable):&amp;#10;    clickOnClickable = np.where(hoverOnClickable,1,0)&amp;#10;    &amp;#10;    eachClickTime.append(probeMouse.mouseClock.getTime())&amp;#10;    eachClickItem.append(clickableLabel[np.where(clickOnClickable == 1)[0]][0])&amp;#10;    #mouse is pressing right now&amp;#10;    mouseIsDown = True&amp;#10;#check for mouse release    &amp;#10;if sum(buttons) == 0 and mouseIsDown:&amp;#10;    #mouse released&amp;#10;    clicksTotal += clickOnClickable&amp;#10;    &amp;#10;    #change opacity&amp;#10;    clicking = clickables[clickOnClickable ==1][0]&amp;#10;    &amp;#10;    #set opacity&amp;#10;    for n,i in enumerate(clickables):&amp;#10;        i.opacity = 1&amp;#10;    clicking.opacity = 0.25&amp;#10;    &amp;#10;    mouseIsDown = False" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="#undraw,reset opacity&amp;#10;for i in clickables:&amp;#10;    i.setAutoDraw(False)&amp;#10;    i.opacity = 1&amp;#10;    if trlType[trlCntTotal] == 0:&amp;#10;        i.size = i.size/visualProbeSizeScalar&amp;#10;    else:&amp;#10;        i.size = i.size*visualProbeSizeScalar&amp;#10;win.flip()&amp;#10;&amp;#10;#resets&amp;#10;kb.clearEvents()&amp;#10;probeMouse.setVisible(0)&amp;#10;&amp;#10;try:&amp;#10;    #add mouse activity&amp;#10;    trials.addData('probeMouse.x', probeMouse.x)&amp;#10;    trials.addData('probeMouse.y', probeMouse.y)&amp;#10;    trials.addData('probeMouse.leftButton', probeMouse.leftButton)&amp;#10;    trials.addData('probeMouse.midButton', probeMouse.midButton)&amp;#10;    trials.addData('probeMouse.rightButton', probeMouse.rightButton)&amp;#10;    trials.addData('probeMouse.time', probeMouse.time)&amp;#10;    trials.addData('probeMouse.mouseOnProbes', probeMouse.clickOn)&amp;#10;&amp;#10;    #add data about probe information&amp;#10;    for label,path in zip(clickableLabel,clickables):&amp;#10;        thisExp.addData(label,path._imName)&amp;#10;        &amp;#10;    #record position for each probe item&amp;#10;    thisExp.addData('probeLocationArr',probePosArr)&amp;#10;    #record the final response&amp;#10;    thisExp.addData('rspIndex',clickOnClickable)&amp;#10;    thisExp.addData('rsp',clickableLabel[np.where(clickOnClickable == 1)[0]][0])&amp;#10;    thisExp.addData('rspPath',clickables[np.where(clickOnClickable == 1)[0]][0]._imName)&amp;#10;&amp;#10;    #record RT&amp;#10;    thisExp.addData('rt',eachClickTime[0])&amp;#10;    thisExp.addData('timeEachClick', eachClickTime)&amp;#10;    thisExp.addData('itemEachClick', eachClickItem)&amp;#10;    thisExp.addData('missingRsp',False)&amp;#10;except:&amp;#10;    thisExp.addData('missingRsp',True)" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawProbe" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="distractor">
      <RoutineSettingsComponent name="distractor" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="distractor" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drawDistractor" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="visualDistractor.setAutoDraw(True)&amp;#10;categoricalDistractor.setAutoDraw(True)&amp;#10;&amp;#10;clock.reset()&amp;#10;kb.clock.reset()&amp;#10;kb.clearEvents()&amp;#10;&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="continuing = True&amp;#10;while clock.getTime() &lt;= distractorT:&amp;#10;    key = kb.getKeys(['escape'], waitRelease=False)&amp;#10;    if 'escape' in key:&amp;#10;          core.quit()" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="visualDistractor.setAutoDraw(False)&amp;#10;categoricalDistractor.setAutoDraw(False)&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drawDistractor" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="elRecord_distractor" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="aaa = core.monotonicClock.getTime;&amp;#10;psychoJS.experiment.addData(&quot;memory_item_start&quot;, aaa().toString());&amp;#10;this_epoch = &quot;stim&quot;;&amp;#10;stim_time = 0.25;&amp;#10;if ((slow_practice &lt; 2)) {&amp;#10;    stim_time = 1.5;&amp;#10;}&amp;#10;el_tracker.sendMessage(&quot;memory_item_start&quot;);&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="this_epoch = 'distractor'&amp;#10;aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'Start',str(aaa()))&amp;#10;&amp;#10;if eyetracking == 1:&amp;#10;    #el_tracker.startRecording(1, 1, 1, 1)&amp;#10;    el_tracker.sendMessage(this_epoch)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="aaa = core.monotonicClock.getTime&amp;#10;thisExp.addData(this_epoch+'End',str(aaa()))&amp;#10;" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="elRecord_distractor" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="instr">
      <RoutineSettingsComponent name="instr" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="instr" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
    </Routine>
    <Routine name="drift_check">
      <RoutineSettingsComponent name="drift_check" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="code" updates="None" name="forceNonSlip"/>
        <Param val="drift_check" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="drift_check_code" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="[scn_width, scn_height];&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="if eyetracking == 1:&amp;#10;    # drift-check and re-do camera setup if ESCAPE is pressed&amp;#10;    try:&amp;#10;        error = el_tracker.doDriftCorrect(int(scn_width/2.0),&amp;#10;                                          int(scn_height/2.0), 1, 1)&amp;#10;        # break following a success drift-check&amp;#10;    except:&amp;#10;        continue&amp;#10;    # put tracker in idle/offline mode before recording&amp;#10;    el_tracker.setOfflineMode()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="drift_check_code" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="loadExpVar"/>
  </Flow>
</PsychoPy2experiment>
